<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rad IA 2.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        :root {
            --primary-color: #4a90e2; /* Azul principal */
            --secondary-color: #50e3c2; /* Verde-água secundário */
            --accent-color-1: #f5a623; /* Laranja para imagens */
            --accent-color-2: #bd10e0; /* Roxo para TTS de texto */
            --accent-color-3: #7ed321; /* Verde para TTS de ficheiro */
            --accent-color-4: #4a4a4a; /* Cinza escuro para falar com IA */
            --accent-color-5: #e91e63; /* Rosa para Gerador de Guiões */
            --background-color: #f4f7f9;
            --card-background-color: #ffffff;
            --text-color: #333;
            --heading-color: #2c3e50;
            --border-color: #e0e6ed;
            --shadow-color: rgba(0, 0, 0, 0.08);
        }

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 0; 
            background-color: var(--background-color); 
            color: var(--text-color);
            min-height: 100vh;
            box-sizing: border-box;
        }

        .top-bar {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 30px;
            width: 100%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            position: sticky; 
            top: 0;
            z-index: 1000; 
        }

        .top-bar .main-title {
            color: white;
            margin: 0;
            font-size: 1.8em; 
            font-weight: 700;
        }
        
        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            gap: 5px; /* Reduzido o gap para caber mais itens */
        }

        nav ul li a {
            color: white;
            text-decoration: none;
            padding: 10px 12px; /* Padding ligeiramente ajustado */
            border-radius: 6px;
            transition: background-color 0.3s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px; 
            font-size: 0.9em; /* Reduzir tamanho da fonte da navegação */
        }

        nav ul li a:hover, nav ul li a.active {
            background-color: rgba(255,255,255,0.2);
        }

        .main-content-area {
            width: 100%;
            max-width: 960px; 
            padding: 30px 20px; 
            box-sizing: border-box;
            margin-top: 70px; 
        }
        
        .generator-section {
            background-color: var(--card-background-color); 
            padding: 25px 30px; 
            border-radius: 10px; 
            box-shadow: 0 8px 16px var(--shadow-color); 
            margin-bottom: 30px; 
            text-align: left; 
            display: none; 
        }
        .generator-section.active {
            display: block;
        }

        .generator-section h2 {
            color: var(--heading-color); 
            margin-top: 0;
            margin-bottom: 25px; 
            font-size: 1.8em; 
            border-bottom: 2px solid var(--border-color); 
            padding-bottom: 15px; 
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px; 
        }
        .generator-section h2 .fa-solid { 
            font-size: 0.9em; 
        }


        #aiGeneratedImageContainer {
            margin-top: 20px;
            padding: 15px;
            border: 2px dashed #d0d9e0; 
            border-radius: 8px;
            background-color: #f8f9fa;
            min-height: 150px; 
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column; 
        }
        #aiGeneratedImage {
            max-width: 100%;
            max-height: 400px;
            border-radius: 6px;
            object-fit: contain; 
        }
        #aiImagePlaceholder {
            color: #6c757d;
            font-size: 0.95em;
        }

        .button-group {
            margin-top: 20px; 
            margin-bottom: 15px; 
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start; 
            gap: 12px; 
        }
        button { 
            padding: 12px 25px; 
            font-size: 0.95em; 
            font-weight: 500;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            transition: background-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
            color: white; 
            letter-spacing: 0.5px;
            display: flex; 
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        button:hover {
            transform: translateY(-2px); 
            box-shadow: 0 6px 12px rgba(0,0,0,0.1); 
        }

        /* Cores específicas dos botões */
        #btnRecordVoice { background-color: var(--accent-color-4); }
        #btnRecordVoice:hover { background-color: #333; }
        #btnRecordVoice.recording { background-color: #e63946; }
        #btnRecordVoice.recording:hover { background-color: #c32f3b; }

        #btnProcessFileToSpeech { background-color: var(--accent-color-3); }
        #btnProcessFileToSpeech:hover { background-color: #6ab01c; }

        #btnGenerateSpeechFromText { background-color: var(--accent-color-2); }
        #btnGenerateSpeechFromText:hover { background-color: #a30dbd; }
        
        #btnGenerateImageFromText { background-color: var(--accent-color-1); }
        #btnGenerateImageFromText:hover { background-color: #d88c1b; }

        #btnDownloadAiImage { background-color: var(--primary-color); }
        #btnDownloadAiImage:hover { background-color: #3a7bc8; }

        #btnDeleteAiImage { background-color: #dc3545; }
        #btnDeleteAiImage:hover { background-color: #c82333; }
        
        #btnGenerateScript, #btnPlayScript { background-color: var(--accent-color-5); }
        #btnGenerateScript:hover, #btnPlayScript:hover { background-color: #c2185b; }


        #errorMessage { 
            color: #721c24; 
            font-weight: 500; 
            margin: 20px auto; 
            padding: 12px 18px; 
            border-radius: 6px;
            background-color: #f8d7da; 
            border: 1px solid #f5c6cb; 
            text-align: left;
            display: none; 
            max-width: 900px; 
        }
        .loading-indicator {
            display: none;
            margin-top: 20px; 
            font-style: italic;
            color: #545d65; 
            font-size: 0.9em;
            text-align: center; 
        }
        textarea { /* Estilo unificado para textareas */
            width: 100%; 
            padding: 12px; 
            margin-top: 10px;
            margin-bottom: 15px; 
            border-radius: 6px;
            border: 1px solid #ced4da;
            font-family: 'Inter', sans-serif;
            font-size: 1em; 
            min-height: 70px; 
            box-sizing: border-box; 
            resize: vertical; 
        }
        input[type="file"] {
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px; 
            border: 1px solid #ced4da;
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 0.95em; 
            width: 100%;
            box-sizing: border-box;
            background-color: #fff; 
        }
        
        #audioPlayerContainer, #voiceChatResponseContainer, #scriptDisplayContainer {
            margin-top: 20px; 
            text-align: center; 
        }
        audio {
            width: 100%;
            max-width: 550px; 
            border-radius: 6px;
        }
        #voiceChatResponseText, #generatedScriptText {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
            text-align: left;
            white-space: pre-wrap; 
            font-size: 0.95em;
            color: #495057;
            border: 1px solid #dae0e5;
            max-height: 400px; /* Para evitar que fique muito longo */
            overflow-y: auto; /* Adicionar scroll se necessário */
        }

        @media (max-width: 768px) {
            .top-bar {
                flex-direction: column;
                padding: 15px;
                 position: static; 
            }
            .main-content-area {
                margin-top: 0; 
            }
            .top-bar .main-title {
                margin-bottom: 15px;
            }
            nav ul {
                flex-direction: row; 
                flex-wrap: wrap;
                justify-content: center;
                width: 100%;
            }
            nav ul li a {
                padding: 8px 10px; 
                font-size: 0.85em; /* Ajustar para caber melhor */
            }
            .main-content-area {
                padding: 20px 15px;
            }
            .generator-section h2 {
                font-size: 1.5em;
            }
            button { 
                width: 100%; 
            }
            .button-group {
                flex-direction: column; 
                align-items: stretch; 
            }
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <h1 class="main-title">Rad IA 2.0</h1>
        <nav>
            <ul>
                <li><a href="#" class="nav-link active" data-target="talkToAiSection"><i class="fa-solid fa-microphone-lines"></i> Falar</a></li>
                <li><a href="#" class="nav-link" data-target="fileToPodcastSection"><i class="fa-solid fa-file-audio"></i> Podcast</a></li>
                <li><a href="#" class="nav-link" data-target="textToSpeechSection"><i class="fa-solid fa-comment-dots"></i> Texto-Fala</a></li>
                <li><a href="#" class="nav-link" data-target="imageGeneratorSection"><i class="fa-solid fa-image"></i> Imagem</a></li>
                <li><a href="#" class="nav-link" data-target="scriptGeneratorSection"><i class="fa-solid fa-scroll"></i> Guião/História</a></li>
            </ul>
        </nav>
    </div>

    <div class="main-content-area">
        <p id="errorMessage"></p> 

        <div id="talkToAiSection" class="generator-section active">
            <h2><i class="fa-solid fa-headset"></i> Falar com a IA</h2>
            <div class="button-group">
                <button id="btnRecordVoice"><i class="fa-solid fa-microphone"></i> Gravar Voz</button>
            </div>
            <div id="voiceChatResponseContainer" style="display:none;">
                <h3>Resposta da IA:</h3>
                <div id="voiceChatResponseText"></div>
            </div>
        </div>

        <div id="fileToPodcastSection" class="generator-section">
            <h2><i class="fa-solid fa-file-invoice"></i> Converter Ficheiro em Podcast (Diálogo)</h2>
            <input type="file" id="fileInput" accept="image/jpeg,image/png,image/gif,image/webp,application/pdf,.txt">
            <div class="button-group">
                <button id="btnProcessFileToSpeech"><i class="fa-solid fa-podcast"></i> Gerar Diálogo em Áudio</button>
            </div>
        </div>
        
        <div id="textToSpeechSection" class="generator-section">
            <h2><i class="fa-solid fa-align-left"></i> Gerador de Fala (Text-to-Speech)</h2>
            <textarea id="ttsInputText" placeholder="Escreva o texto que deseja converter em fala..."></textarea>
            <div class="button-group">
                <button id="btnGenerateSpeechFromText"><i class="fa-solid fa-volume-high"></i> Gerar Fala com IA (Texto)</button>
            </div>
        </div>
        
        <div id="audioPlayerContainer" style="display:none;"> <audio id="audioPlayer" controls></audio>
        </div>

        <div id="imageGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-palette"></i> Criar Imagem com Inteligência Artificial</h2>
            <textarea id="imagePrompt" placeholder="Descreva a imagem que você quer gerar (ex: um gato astronauta a flutuar no espaço, pintura a óleo)"></textarea>
            <div class="button-group">
                <button id="btnGenerateImageFromText"><i class="fa-solid fa-wand-magic-sparkles"></i> Gerar Imagem com IA</button>
            </div>
            <div id="aiGeneratedImageContainer">
                <img id="aiGeneratedImage" src="#" alt="Imagem gerada por IA aparecerá aqui" style="display:none;"/>
                <span id="aiImagePlaceholder">A sua imagem gerada por IA aparecerá aqui.</span>
            </div>
            <div class="button-group">
                <button id="btnDownloadAiImage" style="display:none;"><i class="fa-solid fa-download"></i> Baixar Imagem da IA</button>
                <button id="btnDeleteAiImage" style="display:none;"><i class="fa-solid fa-trash-can"></i> Apagar Imagem da IA</button>
            </div>
        </div>

        <div id="scriptGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-feather-pointed"></i> Gerador de Guiões e Histórias</h2>
            <textarea id="scriptPrompt" placeholder="Descreva o tema, personagens, género ou ideia base para o seu guião ou história..."></textarea>
            <div class="button-group">
                <button id="btnGenerateScript"><i class="fa-solid fa-book-open"></i> Gerar Guião/História</button>
            </div>
            <div id="scriptDisplayContainer" style="display:none;">
                <h3>Guião/História Gerada:</h3>
                <div id="generatedScriptText"></div>
                <div class="button-group">
                    <button id="btnPlayScript" style="display:none;"><i class="fa-solid fa-play-circle"></i> ✨ Ouvir Guião/História</button>
                </div>
            </div>
        </div>
        
        <div class="loading-indicator" id="loadingIndicator">Aguarde, a contactar a API Gemini...</div>
    </div>

    <script>
        // API Keys
        const userProvidedApiKey = "AIzaSyDxcxVmGPBbg7mJ6_cmMDkHrDpbx3Lspik"; 
        const geminiFlashApiKey = userProvidedApiKey; 
        const imagenApiKey = userProvidedApiKey; 
        const ttsApiKey = userProvidedApiKey; 

        // Elementos do DOM
        let errorMessageElement, loadingIndicator;
        let imagePromptTextarea, btnGenerateImageFromText;
        let aiGeneratedImageElement, aiImagePlaceholder, aiGeneratedImageContainer;
        let btnDownloadAiImage, btnDeleteAiImage;
        let ttsInputText, btnGenerateSpeechFromText, audioPlayer, audioPlayerContainer;
        let fileInput, btnProcessFileToSpeech;
        let lastAttemptedMimeType = 'desconhecido'; 
        let btnRecordVoice, voiceChatResponseContainer, voiceChatResponseText;
        let mediaRecorder;
        let audioChunks = [];
        let navLinks, generatorSections;
        // Elementos para Gerador de Guiões
        let scriptPromptTextarea, btnGenerateScript, scriptDisplayContainer, generatedScriptText, btnPlayScript;


        window.onload = function() {
            errorMessageElement = document.getElementById('errorMessage'); 
            loadingIndicator = document.getElementById('loadingIndicator');
            imagePromptTextarea = document.getElementById('imagePrompt');
            btnGenerateImageFromText = document.getElementById('btnGenerateImageFromText');
            aiGeneratedImageElement = document.getElementById('aiGeneratedImage');
            aiImagePlaceholder = document.getElementById('aiImagePlaceholder');
            aiGeneratedImageContainer = document.getElementById('aiGeneratedImageContainer');
            btnDownloadAiImage = document.getElementById('btnDownloadAiImage');
            btnDeleteAiImage = document.getElementById('btnDeleteAiImage');
            ttsInputText = document.getElementById('ttsInputText');
            btnGenerateSpeechFromText = document.getElementById('btnGenerateSpeechFromText'); 
            audioPlayer = document.getElementById('audioPlayer');
            audioPlayerContainer = document.getElementById('audioPlayerContainer');
            fileInput = document.getElementById('fileInput');
            btnProcessFileToSpeech = document.getElementById('btnProcessFileToSpeech');
            btnRecordVoice = document.getElementById('btnRecordVoice');
            voiceChatResponseContainer = document.getElementById('voiceChatResponseContainer');
            voiceChatResponseText = document.getElementById('voiceChatResponseText');
            
            // Gerador de Guiões
            scriptPromptTextarea = document.getElementById('scriptPrompt');
            btnGenerateScript = document.getElementById('btnGenerateScript');
            scriptDisplayContainer = document.getElementById('scriptDisplayContainer');
            generatedScriptText = document.getElementById('generatedScriptText');
            btnPlayScript = document.getElementById('btnPlayScript');

            navLinks = document.querySelectorAll('nav .nav-link');
            generatorSections = document.querySelectorAll('.generator-section');

            navLinks.forEach(link => {
                link.addEventListener('click', function(event) {
                    event.preventDefault();
                    const targetId = this.getAttribute('data-target');
                    navLinks.forEach(navLink => navLink.classList.remove('active'));
                    this.classList.add('active');
                    generatorSections.forEach(section => {
                        section.style.display = section.id === targetId ? 'block' : 'none';
                    });
                    clearErrorMessage(); 
                    audioPlayerContainer.style.display = 'none'; 
                });
            });
            if (navLinks.length > 0) document.querySelector('.nav-link[data-target="talkToAiSection"]').click();

            btnGenerateImageFromText.addEventListener('click', gerarImagemComIA);
            btnDownloadAiImage.addEventListener('click', baixarImagemGeradaIA);
            btnDeleteAiImage.addEventListener('click', apagarImagemGeradaIA);
            btnGenerateSpeechFromText.addEventListener('click', () => { 
                 const textToSpeak = ttsInputText.value.trim();
                 if (textToSpeak) {
                    gerarFalaComIA(textToSpeak, "Texto Introduzido", false); 
                 } else {
                    displayErrorMessage("Por favor, introduza o texto que deseja converter em fala.");
                 }
            });
            btnProcessFileToSpeech.addEventListener('click', processFileToSpeech);
            btnRecordVoice.addEventListener('click', toggleVoiceRecording);
            btnGenerateScript.addEventListener('click', gerarGuiaoHistoria);
            btnPlayScript.addEventListener('click', () => {
                const scriptContent = generatedScriptText.textContent;
                if (scriptContent) {
                    gerarFalaComIA(scriptContent, "Guião/História Gerada", false); // Voz única para narração
                }
            });


            audioPlayer.onerror = function(e) {
                console.error("Erro no elemento de áudio:", e);
                let specificError = "Erro desconhecido ao carregar o áudio.";
                if (audioPlayer.error) {
                    switch (audioPlayer.error.code) {
                        case MediaError.MEDIA_ERR_ABORTED: specificError = "A reprodução do áudio foi abortada."; break;
                        case MediaError.MEDIA_ERR_NETWORK: specificError = "Ocorreu um erro de rede ao carregar o áudio."; break;
                        case MediaError.MEDIA_ERR_DECODE: specificError = "Ocorreu um erro ao descodificar o áudio. O formato pode ser inválido ou não suportado."; break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: specificError = "O formato do áudio não é suportado ou a fonte não pôde ser encontrada."; break;
                        default: specificError = `Ocorreu um erro ao carregar o áudio (código: ${audioPlayer.error.code}).`;
                    }
                }
                displayErrorMessage(specificError + ` (Tipo MIME tentado: ${lastAttemptedMimeType})`);
                audioPlayerContainer.style.display = 'none';
            };
        };

        function displayErrorMessage(message) {
            errorMessageElement.textContent = message;
            errorMessageElement.style.display = 'block';
            errorMessageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function clearErrorMessage() {
            errorMessageElement.textContent = '';
            errorMessageElement.style.display = 'none';
        }

        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(new Error(`Erro ao ler o ficheiro: ${error.message}`));
                reader.readAsDataURL(file);
            });
        }
        
        function readFileAsText(file) {
             return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(new Error(`Erro ao ler o ficheiro de texto: ${error.message}`));
                reader.readAsText(file);
            });
        }

        async function toggleVoiceRecording() {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            } else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' }); 
                    audioChunks = []; 
                    mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                    mediaRecorder.onstart = () => { 
                        btnRecordVoice.innerHTML = '<i class="fa-solid fa-stop"></i> Parar Gravação';
                        btnRecordVoice.classList.add("recording");
                        loadingIndicator.style.display = 'none'; 
                        clearErrorMessage();
                        voiceChatResponseContainer.style.display = 'none';
                        audioPlayerContainer.style.display = 'none'; 
                    };
                    mediaRecorder.onstop = async () => {
                        btnRecordVoice.innerHTML = '<i class="fa-solid fa-microphone"></i> Gravar Voz';
                        btnRecordVoice.classList.remove("recording");
                        loadingIndicator.textContent = "A processar áudio gravado...";
                        loadingIndicator.style.display = 'block';
                        const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
                        audioChunks = []; 
                        stream.getTracks().forEach(track => track.stop()); 
                        try {
                            const base64Audio = await readFileAsBase64(audioBlob);
                            await sendAudioToGemini(base64Audio, mediaRecorder.mimeType);
                        } catch (error) {
                            displayErrorMessage(`Erro ao processar áudio gravado: ${error.message}`);
                        } finally {
                            loadingIndicator.style.display = 'none';
                        }
                    };
                    mediaRecorder.start();
                } catch (error) {
                    displayErrorMessage("Não foi possível aceder ao microfone. Verifique as permissões.");
                    btnRecordVoice.innerHTML = '<i class="fa-solid fa-microphone"></i> Gravar Voz';
                    btnRecordVoice.classList.remove("recording");
                }
            }
        }

        async function sendAudioToGemini(base64AudioData, mimeType) {
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            loadingIndicator.textContent = "A IA está a pensar...";
            loadingIndicator.style.display = 'block';
            const payload = { contents: [{ role: "user", parts: [ { inlineData: { mimeType: mimeType, data: base64AudioData } } ] }] };
            try {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao processar áudio (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const aiResponseText = result.candidates[0].content.parts[0].text;
                    voiceChatResponseText.textContent = aiResponseText;
                    voiceChatResponseContainer.style.display = 'block';
                    await gerarFalaComIA(aiResponseText, "Resposta da IA", false, "Charon"); // Voz Charon para resposta
                } else {
                    throw new Error("Não foi possível obter uma resposta de texto da IA para o áudio enviado.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        async function getSummaryForTTS(base64Data, mimeType, fileType) {
            if (!geminiFlashApiKey) throw new Error("API key para Gemini Flash não configurada.");
            
            let promptText = "";
            let maxTokens = 1500; // Aumentado para PDF e Texto para tentar ~7min
            if (fileType === "image") {
                promptText = "Crie um resumo detalhado desta imagem, com informação suficiente para gerar um diálogo de podcast com cerca de 2-3 minutos de duração. Destaque os elementos visuais principais, a atmosfera geral e em quaisquer textos visíveis. Seja descritivo e envolvente.";
                maxTokens = 700; 
            } else if (fileType === "pdf") {
                promptText = "Crie um resumo detalhado e abrangente deste documento PDF, com informação suficiente para gerar um diálogo de podcast com aproximadamente 7 minutos de duração. Foque-se nas ideias principais, argumentos, exemplos e conclusões, omitindo apenas detalhes menores ou informação redundante. O objetivo é ter material rico para uma discussão entre duas vozes.";
                maxTokens = 3000; 
            } else if (fileType === "text") {
                 promptText = "Crie um resumo detalhado e abrangente deste texto, com informação suficiente para gerar um diálogo de podcast com aproximadamente 7 minutos de duração. Foque-se nas ideias principais, argumentos, exemplos e conclusões. O objetivo é ter material rico para uma discussão entre duas vozes.";
                 maxTokens = 3000; 
            }

            const payload = {
                contents: [{ role: "user", parts: [{ text: promptText }, { inlineData: { mimeType: mimeType, data: base64Data } }] }],
                generationConfig: { maxOutputTokens: maxTokens, temperature: 0.6 } 
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
            loadingIndicator.textContent = `A gerar resumo de ${fileType}...`;
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Erro ao obter resumo de ${fileType} (${response.status}): ${errorData?.error?.message || response.statusText}`);
            }
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                return result.candidates[0].content.parts[0].text;
            }
            throw new Error(`Não foi possível extrair o resumo de ${fileType} da API.`);
        }

        async function generateDialogueFromSummary(summaryText) {
            if (!geminiFlashApiKey) throw new Error("API key para Gemini Flash (geração de diálogo) não configurada.");
            loadingIndicator.textContent = "A criar guião de diálogo para o podcast...";
            
            const prompt = `Com base no seguinte resumo detalhado, crie um guião de diálogo extenso e envolvente (visando aproximadamente 1000-1500 palavras, o que pode equivaler a cerca de 7-10 minutos de fala) entre duas pessoas (identificadas como "Speaker 1:" e "Speaker 2:") para um podcast. O diálogo deve explorar os pontos principais do resumo de forma natural, aprofundada e conversacional, como se fosse uma discussão real. Formate o guião claramente com "Speaker 1:" e "Speaker 2:" antes de cada fala. Não adicione nenhuma introdução ou conclusão ao diálogo, apenas as falas dos speakers. Resumo:\n\n${summaryText}`;
            
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: { maxOutputTokens: 2500, temperature: 0.75 } 
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Erro ao gerar diálogo (${response.status}): ${errorData?.error?.message || response.statusText}`);
            }
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                return result.candidates[0].content.parts[0].text;
            }
            throw new Error("Não foi possível gerar o guião do diálogo a partir do resumo.");
        }


        async function processFileToSpeech() {
            const file = fileInput.files[0];
            if (!file) {
                displayErrorMessage("Por favor, selecione um ficheiro.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.style.display = 'block';
            audioPlayerContainer.style.display = 'none';

            try {
                let summaryText = "";
                let fileDescriptionForTTS = file.name;
                let fileTypeForSummary = "";

                if (file.type.startsWith("image/")) {
                    fileTypeForSummary = "image";
                    const base64FileContent = await readFileAsBase64(file);
                    summaryText = await getSummaryForTTS(base64FileContent, file.type, fileTypeForSummary);
                    fileDescriptionForTTS = `Podcast sobre a imagem ${file.name}`;
                } else if (file.type === "application/pdf") {
                     fileTypeForSummary = "pdf";
                    const base64FileContent = await readFileAsBase64(file);
                    summaryText = await getSummaryForTTS(base64FileContent, "application/pdf", fileTypeForSummary);
                    fileDescriptionForTTS = `Podcast sobre o PDF ${file.name}`;
                } else if (file.type === "text/plain") {
                    fileTypeForSummary = "text"; 
                    const rawText = await readFileAsText(file); 
                    summaryText = await getSummaryForTTS(rawText, "text/plain", fileTypeForSummary); 
                    fileDescriptionForTTS = `Podcast sobre o ficheiro ${file.name}`;
                } else {
                    throw new Error(`Tipo de ficheiro não suportado: ${file.type}. Por favor, selecione uma imagem, PDF ou ficheiro .txt.`);
                }

                if (summaryText) {
                    const dialogueScript = await generateDialogueFromSummary(summaryText);
                    if (dialogueScript) {
                        await gerarFalaComIA(dialogueScript, fileDescriptionForTTS, true); // true para multi-speaker com Charon e Kore
                    } else {
                        throw new Error("Falha ao gerar o guião do diálogo.");
                    }
                } else {
                    throw new Error("Não foi possível extrair ou resumir conteúdo do ficheiro para conversão em fala.");
                }

            } catch (error) {
                console.error("Erro ao processar ficheiro para fala:", error);
                displayErrorMessage(`Erro ao processar ficheiro: ${error.message}`);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        async function gerarGuiaoHistoria() {
            const prompt = scriptPromptTextarea.value.trim();
            if (!prompt) {
                displayErrorMessage("Por favor, forneça um tema ou ideia para o guião/história.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A gerar guião/história...";
            loadingIndicator.style.display = 'block';
            scriptDisplayContainer.style.display = 'none';
            btnPlayScript.style.display = 'none';

            const generationPrompt = `Crie um guião curto ou uma história (aproximadamente 300-500 palavras) com base no seguinte: "${prompt}". Se for um guião, defina claramente os personagens e as suas falas (ex: PERSONAGEM: Fala.). Se for uma história, escreva uma narrativa envolvente.`;

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: generationPrompt }] }],
                    generationConfig: { temperature: 0.8, maxOutputTokens: 800 }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao gerar guião (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const script = result.candidates[0].content.parts[0].text;
                    generatedScriptText.textContent = script;
                    scriptDisplayContainer.style.display = 'block';
                    btnPlayScript.style.display = 'inline-flex'; // Usar inline-flex para o botão
                } else {
                    throw new Error("Não foi possível obter o guião/história da resposta da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }


        async function gerarImagemComIA() {
            const prompt = imagePromptTextarea.value.trim();
            if (!prompt) {
                displayErrorMessage("Por favor, descreva a imagem que deseja gerar.");
                return;
            }
            if (!imagenApiKey) {
                displayErrorMessage("A API key para o serviço de geração de imagem (Imagen) não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.style.display = 'block';
            loadingIndicator.textContent = "A gerar imagem com IA, aguarde...";
            aiGeneratedImageElement.style.display = 'none';
            aiImagePlaceholder.style.display = 'block';
            aiImagePlaceholder.textContent = "A sua imagem gerada por IA aparecerá aqui."; 
            aiImagePlaceholder.style.color = "#6c757d"; 
            btnDownloadAiImage.style.display = 'none';
            btnDeleteAiImage.style.display = 'none';

            try {
                const payload = { 
                    instances: [{ prompt: prompt }],
                    parameters: { "sampleCount": 1 } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${imagenApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Erro da API Imagen:", errorData);
                    let detailedErrorMessage = `Erro da API Imagen (${response.status}): ${response.statusText}.`;
                    if (errorData?.error?.message) {
                        detailedErrorMessage += ` Detalhes: ${errorData.error.message}`;
                        if (errorData.error.message.toLowerCase().includes("billed users") || errorData.error.message.toLowerCase().includes("billing")) {
                             detailedErrorMessage = "Erro: A API de geração de imagens (Imagen) requer uma conta Google Cloud com faturação ativa. Por favor, verifique as configurações da sua conta.";
                        } else if (errorData.error.message.toLowerCase().includes("api key not valid")) {
                            detailedErrorMessage = "Erro: A API key fornecida para a geração de imagens não é válida. Por favor, verifique a API key.";
                        }
                    }
                    throw new Error(detailedErrorMessage);
                }
                const result = await response.json();
                if (result.predictions?.[0]?.bytesBase64Encoded) {
                    const base64ImageData = result.predictions[0].bytesBase64Encoded;
                    aiGeneratedImageElement.src = `data:image/png;base64,${base64ImageData}`;
                    aiGeneratedImageElement.style.display = 'block';
                    aiImagePlaceholder.style.display = 'none';
                    btnDownloadAiImage.style.display = 'inline-block';
                    btnDeleteAiImage.style.display = 'inline-block';
                } else {
                    throw new Error("Não foi possível obter a imagem da resposta da API. A resposta pode não conter os dados esperados.");
                }
            } catch (error) {
                displayErrorMessage(error.message); 
                aiImagePlaceholder.textContent = "Falha ao gerar imagem. Verifique a mensagem de erro acima.";
                aiImagePlaceholder.style.color = "red";
                aiImagePlaceholder.style.display = 'block';
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function baixarImagemGeradaIA() {
            if (!aiGeneratedImageElement.src || aiGeneratedImageElement.src.startsWith('#') || aiGeneratedImageElement.style.display === 'none') { 
                displayErrorMessage("Nenhuma imagem gerada por IA para baixar.");
                return;
            }
            clearErrorMessage();
            try {
                const link = document.createElement('a');
                link.download = 'imagem_gerada_ia.png';
                link.href = aiGeneratedImageElement.src;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (e) {
                displayErrorMessage("Ocorreu um erro ao tentar baixar a imagem da IA.");
            }
        }

        function apagarImagemGeradaIA() {
            aiGeneratedImageElement.src = '#'; 
            aiGeneratedImageElement.style.display = 'none';
            aiImagePlaceholder.textContent = "A sua imagem gerada por IA aparecerá aqui.";
            aiImagePlaceholder.style.color = "#6c757d";
            aiImagePlaceholder.style.display = 'block';
            btnDownloadAiImage.style.display = 'none';
            btnDeleteAiImage.style.display = 'none';
            clearErrorMessage();
        }

        function parseAudioMimeType(mimeTypeString) {
            const params = { rate: 24000, bitsPerSample: 16, channels: 1 }; 
            if (!mimeTypeString) return params;
            const parts = mimeTypeString.toLowerCase().split(';');
            parts.forEach(part => {
                const [key, value] = part.trim().split('=');
                if (key === 'rate' && !isNaN(parseInt(value))) {
                    params.rate = parseInt(value);
                } else if (key.startsWith('audio/l') && !isNaN(parseInt(key.substring(7)))) { 
                     params.bitsPerSample = parseInt(key.substring(7));
                } else if (key === 'channels' && !isNaN(parseInt(value))) {
                    params.channels = parseInt(value);
                }
            });
            if (parts[0].startsWith("audio/l")) {
                const bpsStr = parts[0].substring(7);
                if (!isNaN(parseInt(bpsStr))) {
                    params.bitsPerSample = parseInt(bpsStr);
                }
            }
            return params;
        }

        function convertPcmToWav(base64PcmData, originalMimeType) {
            console.log("A converter PCM para WAV. MimeType Original:", originalMimeType);
            const pcmData = Uint8Array.from(atob(base64PcmData), c => c.charCodeAt(0));
            const params = parseAudioMimeType(originalMimeType);
            const sampleRate = params.rate;
            const numChannels = params.channels; 
            const bitsPerSample = params.bitsPerSample;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = pcmData.length;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true); 
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); 
            view.setUint16(20, 1, true);  
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            new Uint8Array(buffer, 44).set(pcmData);
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        async function gerarFalaComIA(textToSpeak, sourceTitle = "Texto", isMultiSpeaker = false, singleVoiceName = "Charon") { 
            if (!textToSpeak || textToSpeak.trim() === "") {
                displayErrorMessage("Não há texto para converter em fala.");
                audioPlayerContainer.style.display = 'none';
                return;
            }
            if (!ttsApiKey) {
                displayErrorMessage("A API key para o serviço de Text-to-Speech (TTS) não está configurada.");
                audioPlayerContainer.style.display = 'none';
                return;
            }
            clearErrorMessage();
            loadingIndicator.style.display = 'block';
            loadingIndicator.textContent = `A gerar fala para "${sourceTitle}", aguarde...`;
            audioPlayerContainer.style.display = 'none'; 

            try {
                const ttsModel = "gemini-2.5-pro-preview-tts"; 
                let speechConfigPayload = {};

                if (isMultiSpeaker) {
                    speechConfigPayload = { 
                        multiSpeakerVoiceConfig: {
                            speakerVoiceConfigs: [ // Vozes para o diálogo do podcast
                                { speaker: "Speaker 1", voiceConfig: { prebuiltVoiceConfig: { voice_name: "Charon" } } }, 
                                { speaker: "Speaker 2", voiceConfig: { prebuiltVoiceConfig: { voice_name: "Kore" } } }   
                            ]
                        }
                    };
                } else {
                     speechConfigPayload = { 
                        voiceConfig: { 
                            prebuiltVoiceConfig: { voice_name: singleVoiceName } // Usa a voz passada como argumento
                        }
                    };
                }

                const payload = {
                    contents: [{ 
                        role: "user", 
                        parts: [{ text: textToSpeak }] 
                    }],
                    generationConfig: {
                        response_modalities: ["audio"],
                        temperature: 0.7, 
                        speechConfig: speechConfigPayload
                    }
                };
                
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${ttsModel}:generateContent?key=${ttsApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Erro da API TTS:", errorData);
                    let detailedErrorMessage = `Erro da API TTS (${response.status}): ${response.statusText || 'Erro desconhecido'}.`;
                    if (errorData?.error?.message) {
                        detailedErrorMessage += ` Detalhes: ${errorData.error.message}`;
                         if (response.status === 429 || errorData.error.message.toLowerCase().includes("quota") || errorData.error.message.toLowerCase().includes("resource_exhausted")) {
                            detailedErrorMessage = "Erro: Excedeu a sua quota atual para o serviço TTS. Por favor, verifique o seu plano e detalhes de faturação ou tente novamente mais tarde.";
                             if (errorData.details) { 
                                const helpLinkObj = errorData.details.find(d => d["@type"] === "type.googleapis.com/google.rpc.Help");
                                const helpLink = helpLinkObj?.links?.[0]?.url;
                                if (helpLink) {
                                    detailedErrorMessage += ` Consulte: ${helpLink}`;
                                }
                            }
                        } else if (response.status === 500 || errorData.error.message.toLowerCase().includes("internal error")) {
                            detailedErrorMessage = `Erro Interno do Servidor (500) ao contactar a API TTS. Por favor, tente novamente mais tarde. Se o problema persistir, reporte em https://developers.generativeai.google/guide/troubleshooting. (Detalhe API: ${errorData.error.message})`;
                        } else if (errorData.error.message.toLowerCase().includes("api key not valid")) {
                            detailedErrorMessage = "Erro: A API key fornecida para o serviço de TTS não é válida ou o modelo não está acessível com esta chave.";
                        } else if (errorData.error.message.toLowerCase().includes("billed users") || errorData.error.message.toLowerCase().includes("billing")) {
                             detailedErrorMessage = "Erro: A API de TTS pode requerer uma conta Google Cloud com faturação ativa.";
                        } else if (errorData.error.message.toLowerCase().includes("model not found") || errorData.error.message.toLowerCase().includes("is not supported") || errorData.error.message.toLowerCase().includes("voice name") ) {
                            detailedErrorMessage = `Erro: O modelo TTS ('${ttsModel}') ou a voz configurada não foram encontrados ou não são suportados. Verifique o nome do modelo, a voz e a documentação da API. (Detalhe API: ${errorData.error.message})`;
                        }
                    }
                    throw new Error(detailedErrorMessage);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0) {
                    const candidate = result.candidates[0];
                    if (candidate.finishReason !== "STOP") {
                         if (!candidate.content?.parts?.[0]?.inlineData?.data) {
                            let finishReasonMessage = `O modelo TTS não concluiu a geração com sucesso. Motivo: ${candidate.finishReason || 'Desconhecido'}. Não foi possível obter dados de áudio.`;
                            if (candidate.finishReason === "OTHER") { 
                                finishReasonMessage += " Isto pode indicar um problema com o texto de entrada (demasiado longo, caracteres inválidos), uma instabilidade temporária da API, ou o modelo pode não ter conseguido gerar áudio para este pedido específico. Tente com um texto mais simples ou mais curto, ou aguarde um pouco e tente novamente.";
                            }
                            throw new Error(finishReasonMessage);
                         }
                         console.warn(`O modelo TTS terminou com o motivo: ${candidate.finishReason || 'Desconhecido'}. A tentar usar os dados de áudio se disponíveis.`);
                    }

                    if (candidate.content?.parts?.[0]?.inlineData?.data) {
                        let audioDataB64 = candidate.content.parts[0].inlineData.data;
                        let finalMimeType = candidate.content.parts[0].inlineData.mimeType || 'audio/L16;rate=24000'; 
                        lastAttemptedMimeType = finalMimeType; 
                        console.log("Áudio recebido da API. MIME Type Original:", finalMimeType, "Tamanho (base64):", audioDataB64.length);
                        if (!audioDataB64.trim()) { 
                            throw new Error("Os dados de áudio recebidos da API estão vazios.");
                        }
                        if (finalMimeType.toLowerCase().includes("audio/l16") || 
                            finalMimeType.toLowerCase().includes("audio/l24") || 
                            finalMimeType.toLowerCase().includes("audio/l32") ||
                            finalMimeType.toLowerCase().includes("pcm")) {
                            try {
                                audioDataB64 = convertPcmToWav(audioDataB64, finalMimeType);
                                finalMimeType = 'audio/wav'; 
                                lastAttemptedMimeType = finalMimeType;
                                console.log("Áudio convertido para WAV. Novo MIME Type:", finalMimeType);
                            } catch (conversionError) {
                                console.error("Erro ao converter PCM para WAV:", conversionError);
                                throw new Error(`Falha ao converter áudio PCM para WAV: ${conversionError.message}`);
                            }
                        }
                        audioPlayer.src = `data:${finalMimeType};base64,${audioDataB64}`;
                        audioPlayer.onloadeddata = function() { 
                            console.log("Dados do áudio carregados (onloadeddata).");
                            audioPlayerContainer.style.display = 'block';
                            audioPlayer.play().catch(playError => { 
                                console.error("Erro ao tentar reproduzir o áudio:", playError);
                                displayErrorMessage("Erro ao iniciar a reprodução do áudio. Interação do utilizador pode ser necessária ou o formato de áudio pode não ser suportado.");
                            });
                        };
                        audioPlayer.load(); 
                        console.log("Fala gerada e src do áudio definido. A aguardar carregamento do áudio...");
                    } else {
                        console.error("Resposta da API TTS não contém dados de áudio válidos, mesmo com finishReason STOP (ou outro):", result);
                        throw new Error("Não foi possível obter os dados de áudio da resposta da API TTS. A estrutura da resposta pode estar incompleta.");
                    }
                } else {
                    console.error("Resposta inesperada da API TTS (sem candidatos):", result);
                    throw new Error("Resposta da API TTS não contém 'candidates'.");
                }
            } catch (error) {
                console.error("Erro ao gerar fala com IA:", error);
                displayErrorMessage(error.message);
                audioPlayerContainer.style.display = 'none';
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
    </script>

</body>
</html>
