<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rad IA 2.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.min.js"></script>
    <style>
        :root {
            --primary-red: #e50914; 
            --dark-background: #141414; 
            --medium-dark-background: #1f1f1f; 
            --light-text: #ffffff;
            --medium-gray-text: #b3b3b3; 
            --dark-gray-text: #808080; 
            --accent-color-1: #f5a623; /* Laranja para imagens */
            --accent-color-2: #bd10e0; /* Roxo para TTS de texto */
            --accent-color-3: #7ed321; /* Verde para TTS de ficheiro e PDF export */
            --accent-color-4: #6c757d; /* Cinza para Falar com IA */
            --accent-color-5: #e91e63; /* Rosa para Gerador de Guiões */
            --accent-color-6: #00bcd4; /* Ciano para Gerador de Atividades */
            --accent-color-7: #3f51b5; /* Indigo para Pesquisa e Chat */
            --accent-color-8: #009688; /* Teal para Tradutor */
            --accent-color-9: #ff5722; /* Deep Orange para Slides */
            --accent-color-10: #607d8b; /* Blue Grey para Relatórios */
            --accent-color-11: #4CAF50; /* Verde para Gerador de Ideias */
            --accent-color-12: #D2691E; /* Chocolate Brown para Receitas */
            --border-color: #303030; 
            --shadow-color: rgba(0, 0, 0, 0.2); 
        }

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 0; 
            background-color: var(--dark-background); 
            color: var(--light-text); 
            min-height: 100vh;
            box-sizing: border-box;
            overflow-x: hidden; 
        }

        .top-bar {
            background-color: #000000; 
            color: var(--light-text);
            padding: 10px 20px; 
            width: 100%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            position: fixed; 
            top: 0;
            left: 0;
            z-index: 1000; 
        }

        .top-bar .main-title {
            color: var(--primary-red); 
            margin: 0;
            font-size: 1.6em; 
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        #mainMenuButton {
            background-color: transparent;
            border: 1px solid var(--primary-red);
            color: var(--primary-red);
            padding: 8px 12px;
            font-size: 0.9em;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        #mainMenuButton:hover {
            background-color: var(--primary-red);
            color: var(--light-text);
        }
        #mainMenuButton .fa-solid {
            margin-right: 8px;
        }

        .side-menu {
            height: 100%;
            width: 0; 
            position: fixed;
            z-index: 1001; 
            top: 0;
            left: 0;
            background-color: #111; 
            overflow-x: hidden;
            transition: 0.3s ease-in-out; /* Transição mais suave */
            padding-top: 60px; 
            box-shadow: 3px 0px 10px rgba(0,0,0,0.5);
        }
        .side-menu a {
            padding: 10px 15px 10px 25px;
            text-decoration: none;
            font-size: 1.0em; 
            color: var(--medium-gray-text);
            display: block;
            transition: 0.3s;
            white-space: nowrap;
        }
        .side-menu a:hover, .side-menu a.active {
            color: var(--primary-red);
            background-color: #222;
        }
        .side-menu .close-btn {
            position: absolute;
            top: 15px;
            right: 25px;
            font-size: 36px;
            margin-left: 50px;
            color: var(--light-text);
            cursor: pointer;
        }
        .side-menu a .fa-solid {
            margin-right: 10px;
            width: 20px; 
            text-align: center;
        }


        .main-content-area {
            width: 100%;
            max-width: 960px; 
            padding: 20px; 
            box-sizing: border-box;
            margin-top: 80px; 
            transition: margin-left .3s ease-in-out; 
        }
        
        .generator-section {
            background-color: var(--medium-dark-background); 
            padding: 20px 25px; 
            border-radius: 10px; 
            box-shadow: 0 8px 20px var(--shadow-color); 
            margin-bottom: 30px; 
            text-align: left; 
            display: none; 
            border: 1px solid var(--border-color);
        }
        .generator-section.active {
            display: block;
        }

        .generator-section h2 {
            color: var(--light-text); 
            margin-top: 0;
            margin-bottom: 20px; 
            font-size: 1.6em; 
            border-bottom: 2px solid var(--primary-red); 
            padding-bottom: 12px; 
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px; 
        }
        .generator-section h2 .fa-solid { 
            font-size: 0.9em; 
            color: var(--primary-red); 
        }
        .generator-section h3 {
            color: var(--medium-gray-text);
            font-size: 1.1em;
            margin-top: 15px;
            margin-bottom: 8px;
        }
        .checkbox-group {
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .checkbox-group label {
            margin-right: 15px;
            color: var(--medium-gray-text);
            font-size: 0.9em;
        }
        .checkbox-group input[type="checkbox"] {
            margin-right: 5px;
            accent-color: var(--primary-red);
        }


        #aiGeneratedImageContainer {
            margin-top: 15px;
            padding: 10px;
            border: 2px dashed var(--dark-gray-text); 
            border-radius: 8px;
            background-color: var(--dark-background); 
            min-height: 150px; 
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column; 
        }
        #aiGeneratedImage {
            max-width: 100%;
            max-height: 350px; 
            border-radius: 6px;
            object-fit: contain; 
        }
        #aiImagePlaceholder {
            color: var(--medium-gray-text);
            font-size: 0.9em;
        }

        .button-group {
            margin-top: 15px; 
            margin-bottom: 10px; 
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start; 
            gap: 10px; 
        }
        button { 
            padding: 10px 20px; 
            font-size: 0.9em; 
            font-weight: 600; 
            cursor: pointer;
            border: none;
            border-radius: 6px;
            transition: background-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
            color: var(--light-text); 
            letter-spacing: 0.5px;
            display: flex; 
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-transform: uppercase; 
        }
        button:hover {
            transform: translateY(-2px); 
            box-shadow: 0 6px 12px rgba(0,0,0,0.2); 
        }

        #btnSendChatMessage { background-color: var(--accent-color-7); } 
        #btnSendChatMessage:hover { background-color: #303f9f; }

        #btnGenerateRecipe { background-color: var(--accent-color-12); }
        #btnGenerateRecipe:hover { background-color: #b85b1a; }


        #errorMessage { 
            color: #f8d7da; 
            font-weight: 500; 
            margin: 20px auto; 
            padding: 12px 18px; 
            border-radius: 6px;
            background-color: #721c24; 
            border: 1px solid #f5c6cb; 
            text-align: left;
            display: none; 
            max-width: 900px; 
        }
        .loading-indicator {
            display: none;
            margin-top: 20px; 
            font-style: italic;
            color: var(--medium-gray-text); 
            font-size: 0.9em;
            text-align: center; 
        }
        textarea, select { 
            width: 100%; 
            padding: 10px; 
            margin-top: 8px;
            margin-bottom: 12px; 
            border-radius: 6px;
            border: 1px solid var(--dark-gray-text);
            font-family: 'Inter', sans-serif;
            font-size: 0.95em; 
            min-height: 40px; 
            box-sizing: border-box; 
            background-color: #2b2b2b; 
            color: var(--light-text); 
        }
        textarea {
            min-height: 70px;
            resize: vertical; 
        }
        textarea::placeholder {
            color: var(--medium-gray-text);
        }
        input[type="file"] {
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px; 
            border: 1px solid var(--dark-gray-text);
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 0.95em; 
            width: 100%;
            box-sizing: border-box;
            background-color: #2b2b2b; 
            color: var(--light-text);
        }
        input[type="file"]::file-selector-button { 
            background-color: var(--primary-red);
            color: var(--light-text);
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #c50812;
        }
        
        #audioPlayerContainer, #voiceChatResponseContainer, #scriptDisplayContainer, 
        #activityDisplayContainer, #searchResultsContainer, #translatedTextContainer, 
        #slideContentContainer, #reportContentContainer, #ideasDisplayContainer, #recipeDisplayContainer {
            margin-top: 20px; 
            text-align: center; 
        }
        audio {
            width: 100%;
            max-width: 550px; 
            border-radius: 6px;
        }
        #voiceChatResponseText, #generatedScriptText, #generatedActivityText, 
        #searchResultsText, #translatedTextOutput, #generatedSlideContent, 
        #generatedReportContent, #generatedIdeasText, #generatedRecipeText {
            background-color: #2b2b2b; 
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
            text-align: left;
            white-space: pre-wrap; 
            font-size: 0.95em;
            color: var(--light-text); 
            border: 1px solid var(--border-color);
            max-height: 400px; 
            overflow-y: auto; 
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--medium-gray-text);
        }


        @media (max-width: 768px) {
            .top-bar {
                padding: 10px 15px;
            }
            .top-bar .main-title {
                font-size: 1.3em; 
            }
            #mainMenuButton {
                font-size: 0.8em;
                padding: 6px 10px;
            }
            .side-menu {
                padding-top: 50px;
            }
            .side-menu a {
                font-size: 1em;
                padding: 8px 10px 8px 20px;
            }
            .side-menu .close-btn {
                top: 10px;
                right: 20px;
                font-size: 30px;
            }
            .main-content-area {
                margin-top: 60px; 
                padding: 15px 10px;
            }
            .generator-section h2 {
                font-size: 1.4em;
            }
            button { 
                width: 100%; 
                padding: 12px 15px; 
            }
            .button-group {
                flex-direction: column; 
                align-items: stretch; 
            }
            textarea, select, input[type="file"] {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <h1 class="main-title">Rad IA 2.0</h1>
        <button id="mainMenuButton"><i class="fa-solid fa-bars"></i> RAD IA MENU</button>
    </div>

    <div id="sideMenu" class="side-menu">
        <a href="javascript:void(0)" class="close-btn" id="closeMenuButton">&times;</a>
        <a href="#" class="tool-link active" data-target="talkToAiSection"><i class="fa-solid fa-microphone-lines"></i> Falar</a>
        <a href="#" class="tool-link" data-target="fileToPodcastSection"><i class="fa-solid fa-file-audio"></i> Podcast</a>
        <a href="#" class="tool-link" data-target="textToSpeechSection"><i class="fa-solid fa-comment-dots"></i> Texto-Fala</a>
        <a href="#" class="tool-link" data-target="imageGeneratorSection"><i class="fa-solid fa-image"></i> Imagem</a>
        <a href="#" class="tool-link" data-target="scriptGeneratorSection"><i class="fa-solid fa-scroll"></i> Guião</a>
        <a href="#" class="tool-link" data-target="translatorSection"><i class="fa-solid fa-language"></i> Tradutor</a>
        <a href="#" class="tool-link" data-target="ideaGeneratorSection"><i class="fa-solid fa-lightbulb"></i> Ideias</a>
        <a href="#" class="tool-link" data-target="recipeGeneratorSection"><i class="fa-solid fa-utensils"></i> Receitas</a>
        <a href="#" class="tool-link" data-target="activityGeneratorSection"><i class="fa-solid fa-graduation-cap"></i> Atividades</a>
        <a href="#" class="tool-link" data-target="slideGeneratorSection"><i class="fa-solid fa-person-chalkboard"></i> Slides</a>
        <a href="#" class="tool-link" data-target="reportGeneratorSection"><i class="fa-solid fa-file-signature"></i> Relatórios</a>
        <a href="#" class="tool-link" data-target="searchAiSection"><i class="fa-solid fa-search"></i> Pesquisa</a>
        <a href="#" class="tool-link" data-target="radimakChatSection"><i class="fa-solid fa-robot"></i> Radimak</a>
    </div>


    <div class="main-content-area" id="mainContentArea">
        <p id="errorMessage"></p> 

        <div id="talkToAiSection" class="generator-section active">
            <h2><i class="fa-solid fa-headset"></i> Falar com a IA</h2>
            <div class="form-group">
                <label for="talkAiVoiceSelect">Escolha a Voz da IA:</label>
                <select id="talkAiVoiceSelect"></select>
            </div>
            <div class="button-group">
                <button id="btnRecordVoice"><i class="fa-solid fa-microphone"></i> Gravar Voz</button>
            </div>
            <div id="voiceChatResponseContainer" style="display:none;">
                <h3>Resposta da IA:</h3>
                <div id="voiceChatResponseText"></div>
            </div>
        </div>

        <div id="fileToPodcastSection" class="generator-section">
            <h2><i class="fa-solid fa-file-invoice"></i> Converter Ficheiro em Podcast (Diálogo)</h2>
            <input type="file" id="fileInput" accept="image/jpeg,image/png,image/gif,image/webp,application/pdf,.txt">
            <div class="form-group">
                <label for="podcastSpeaker1Voice">Voz do Apresentador 1:</label>
                <select id="podcastSpeaker1Voice"></select>
            </div>
            <div class="form-group">
                <label for="podcastSpeaker2Voice">Voz do Apresentador 2:</label>
                <select id="podcastSpeaker2Voice"></select>
            </div>
            <div class="button-group">
                <button id="btnProcessFileToSpeech"><i class="fa-solid fa-podcast"></i> Gerar Diálogo em Áudio</button>
                <button id="btnExportPodcastScriptPdf" style="display:none;"><i class="fa-solid fa-file-pdf"></i> Exportar Guião para PDF</button>
            </div>
             <div id="podcastScriptDisplayContainer" style="display:none;">
                <h3>Guião do Podcast Gerado:</h3>
                <div id="generatedPodcastScriptText"></div>
            </div>
        </div>
        
        <div id="textToSpeechSection" class="generator-section">
            <h2><i class="fa-solid fa-align-left"></i> Gerador de Fala (Text-to-Speech)</h2>
            <textarea id="ttsInputText" placeholder="Escreva o texto que deseja converter em fala..."></textarea>
            <div class="form-group">
                <label for="ttsVoiceSelect">Escolha a Voz:</label>
                <select id="ttsVoiceSelect"></select>
            </div>
            <div class="button-group">
                <button id="btnGenerateSpeechFromText"><i class="fa-solid fa-volume-high"></i> Gerar Fala com IA (Texto)</button>
            </div>
        </div>
        
        <div id="audioPlayerContainer" style="display:none;"> 
            <audio id="audioPlayer" controls></audio>
        </div>

        <div id="imageGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-palette"></i> Criar Imagem com Inteligência Artificial</h2>
            <textarea id="imagePrompt" placeholder="Descreva a imagem que você quer gerar (ex: um gato astronauta a flutuar no espaço, pintura a óleo)"></textarea>
            <div class="button-group">
                <button id="btnGenerateImageFromText"><i class="fa-solid fa-wand-magic-sparkles"></i> Gerar Imagem com IA</button>
            </div>
            <div id="aiGeneratedImageContainer">
                <img id="aiGeneratedImage" src="#" alt="Imagem gerada por IA aparecerá aqui" style="display:none;"/>
                <span id="aiImagePlaceholder">A sua imagem gerada por IA aparecerá aqui.</span>
            </div>
            <div class="button-group">
                <button id="btnDownloadAiImage" style="display:none;"><i class="fa-solid fa-download"></i> Baixar Imagem da IA</button>
                <button id="btnDeleteAiImage" style="display:none;"><i class="fa-solid fa-trash-can"></i> Apagar Imagem da IA</button>
            </div>
        </div>

        <div id="scriptGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-feather-pointed"></i> Gerador de Guiões e Histórias</h2>
            <textarea id="scriptPrompt" placeholder="Descreva o tema, personagens, género ou ideia base para o seu guião ou história..."></textarea>
            <div class="form-group">
                <label for="scriptVoiceSelect">Voz para Narração:</label>
                <select id="scriptVoiceSelect"></select>
            </div>
            <div class="button-group">
                <button id="btnGenerateScript"><i class="fa-solid fa-book-open"></i> Gerar Guião/História</button>
            </div>
            <div id="scriptDisplayContainer" style="display:none;">
                <h3>Guião/História Gerada:</h3>
                <div id="generatedScriptText"></div>
                <div class="button-group">
                    <button id="btnPlayScript" style="display:none;"><i class="fa-solid fa-play-circle"></i> ✨ Ouvir Guião/História</button>
                </div>
            </div>
        </div>

        <div id="translatorSection" class="generator-section">
            <h2><i class="fa-solid fa-language"></i> Tradutor de Texto Inteligente</h2>
            <div class="form-group">
                <label for="sourceTextToTranslate">Texto para Traduzir:</label>
                <textarea id="sourceTextToTranslate" placeholder="Introduza o texto aqui..."></textarea>
            </div>
            <div class="form-group">
                <label for="sourceLanguageSelect">Língua de Origem:</label>
                <select id="sourceLanguageSelect">
                    <option value="auto">Detetar Automaticamente</option>
                    <option value="pt">Português</option> <option value="en">Inglês</option> <option value="es">Espanhol</option> <option value="fr">Francês</option> <option value="de">Alemão</option> <option value="it">Italiano</option> <option value="ja">Japonês</option> <option value="ko">Coreano</option> <option value="zh">Chinês (Simplificado)</option>
                </select>
            </div>
            <div class="form-group">
                <label for="targetLanguageSelect">Língua de Destino:</label>
                <select id="targetLanguageSelect">
                    <option value="pt">Português</option> <option value="en" selected>Inglês</option> <option value="es">Espanhol</option> <option value="fr">Francês</option> <option value="de">Alemão</option> <option value="it">Italiano</option> <option value="ja">Japonês</option> <option value="ko">Coreano</option> <option value="zh">Chinês (Simplificado)</option>
                </select>
            </div>
            <div class="form-group">
                <label for="translatorVoiceSelect">Voz para Tradução:</label>
                <select id="translatorVoiceSelect"></select>
            </div>
            <div class="button-group">
                <button id="btnTranslateText"><i class="fa-solid fa-exchange-alt"></i> Traduzir Texto</button>
            </div>
            <div id="translatedTextContainer" style="display:none;">
                <h3>Texto Traduzido:</h3>
                <div id="translatedTextOutput"></div>
                <div class="button-group">
                    <button id="btnPlayTranslatedText" style="display:none;"><i class="fa-solid fa-volume-up"></i> ✨ Ouvir Tradução</button>
                </div>
            </div>
        </div>
        
        <div id="ideaGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-lightbulb"></i> Gerador de Ideias e Brainstorming</h2>
            <textarea id="ideaTopicInput" placeholder="Introduza um tópico, problema ou questão para brainstorming..."></textarea>
            <div class="button-group">
                <button id="btnGenerateIdeas"><i class="fa-solid fa-brain"></i> Gerar Ideias</button>
                <button id="btnExportIdeasPdf" style="display:none;"><i class="fa-solid fa-file-pdf"></i> Exportar Ideias para PDF</button>
            </div>
            <div id="ideasDisplayContainer" style="display:none;">
                <h3>Ideias Geradas:</h3>
                <div id="generatedIdeasText"></div>
            </div>
        </div>

         <div id="recipeGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-utensils"></i> Gerador de Receitas</h2>
            <div class="form-group">
                <label for="recipeIngredients">Ingredientes (separados por vírgula):</label>
                <textarea id="recipeIngredients" placeholder="Ex: tomate, cebola, alho, frango, arroz"></textarea>
            </div>
            <div class="form-group">
                <label for="recipeCuisineType">Tipo de Cozinha (opcional):</label>
                <select id="recipeCuisineType">
                    <option value="">Qualquer</option>
                    <option value="Italiana">Italiana</option>
                    <option value="Mexicana">Mexicana</option>
                    <option value="Indiana">Indiana</option>
                    <option value="Chinesa">Chinesa</option>
                    <option value="Japonesa">Japonesa</option>
                    <option value="Brasileira">Brasileira</option>
                    <option value="Mediterrânea">Mediterrânea</option>
                    <option value="Vegetariana">Vegetariana</option>
                    <option value="Vegana">Vegana</option>
                    <option value="Rápida e Fácil">Rápida e Fácil</option>
                </select>
            </div>
            <div class="form-group">
                <label for="recipeDifficulty">Nível de Dificuldade (opcional):</label>
                <select id="recipeDifficulty">
                    <option value="">Qualquer</option>
                    <option value="Fácil">Fácil</option>
                    <option value="Médio">Médio</option>
                    <option value="Difícil">Difícil</option>
                </select>
            </div>
            <div class="button-group">
                <button id="btnGenerateRecipe"><i class="fa-solid fa-hat-chef"></i> Gerar Receita</button>
                <button id="btnExportRecipePdf" style="display:none;"><i class="fa-solid fa-file-pdf"></i> Exportar Receita para PDF</button>
                <button id="btnPlayRecipe" style="display:none;"><i class="fa-solid fa-volume-high"></i> ✨ Ouvir Receita</button>
            </div>
            <div id="recipeDisplayContainer" style="display:none;">
                <h3>Receita Gerada:</h3>
                <div id="generatedRecipeText"></div>
            </div>
        </div>


        <div id="activityGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-graduation-cap"></i> Gerador de Atividades Escolares</h2>
            <div class="form-group">
                <label for="activityYearSelect">Ano Escolar:</label>
                <select id="activityYearSelect">
                    <option value="6">6º Ano - Ensino Fundamental</option> <option value="7">7º Ano - Ensino Fundamental</option> <option value="8">8º Ano - Ensino Fundamental</option> <option value="9">9º Ano - Ensino Fundamental</option>
                </select>
            </div>
            <div class="form-group">
                <label for="activitySubjectSelect">Matéria:</label>
                <select id="activitySubjectSelect"> </select>
            </div>
            <div class="form-group">
                <label for="activitySpecificContentSelect">Conteúdo Específico:</label>
                 <select id="activitySpecificContentSelect"> </select>
            </div>
            <div class="form-group">
                <label for="activityQuestionTypeSelect">Tipo de Questão:</label>
                 <select id="activityQuestionTypeSelect">
                    <option value="Ambas">Ambas (Objetivas e Subjetivas)</option>
                    <option value="Objetivas">Apenas Objetivas (ex: múltipla escolha, V/F)</option>
                    <option value="Subjetivas">Apenas Subjetivas (ex: dissertativas, problemas)</option>
                 </select>
            </div>
            <div class="form-group">
                <label for="activityNumQuestionsSelect">Número de Questões:</label>
                <select id="activityNumQuestionsSelect">
                    <option value="5">5 Questões</option> <option value="10">10 Questões</option> <option value="15">15 Questões</option>
                </select>
            </div>
            <div class="button-group">
                <button id="btnGenerateActivity"><i class="fa-solid fa-cogs"></i> Gerar Atividades</button>
            </div>
            <div id="activityDisplayContainer" style="display:none;">
                <h3>Atividades Geradas:</h3>
                <div id="generatedActivityText"></div>
                 <div class="button-group">
                    <button id="btnExportActivityPdf" style="display:none;"><i class="fa-solid fa-file-pdf"></i> Exportar Atividades para PDF</button>
                </div>
            </div>
        </div>

        <div id="slideGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-person-chalkboard"></i> Gerador de Slides</h2>
            <div class="form-group">
                <label for="slideTopicInput">Tema Principal dos Slides:</label>
                <textarea id="slideTopicInput" placeholder="Ex: A Revolução Francesa, O Ciclo da Água, Introdução à Álgebra..."></textarea>
            </div>
            <div class="form-group">
                <label for="slideNumSlidesInput">Número Aproximado de Slides:</label>
                <select id="slideNumSlidesInput">
                    <option value="5">5 Slides</option>
                    <option value="10" selected>10 Slides</option>
                    <option value="15">15 Slides</option>
                </select>
            </div>
             <div class="checkbox-group">
                <input type="checkbox" id="slideIncludeImagesCheckbox" checked>
                <label for="slideIncludeImagesCheckbox">Sugerir Imagens (a IA descreverá imagens relevantes)</label>
            </div>
            <div class="button-group">
                <button id="btnGenerateSlide"><i class="fa-solid fa-file-powerpoint"></i> Gerar Conteúdo dos Slides</button>
                 <button id="btnExportSlidePdf" style="display:none;"><i class="fa-solid fa-file-pdf"></i> Exportar para PDF</button>
                 <button id="btnExportSlidePptx" style="display:none;"><i class="fa-solid fa-file-powerpoint"></i> Exportar para PPTX</button>
            </div>
            <div id="slideContentContainer" style="display:none;">
                <h3>Conteúdo dos Slides Gerado:</h3>
                <div id="generatedSlideContent"></div>
            </div>
        </div>

        <div id="reportGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-file-signature"></i> Gerador de Relatórios</h2>
            <div class="form-group">
                <label for="reportTopicInput">Tema do Relatório:</label>
                <textarea id="reportTopicInput" placeholder="Ex: Impacto das Redes Sociais na Juventude, Fontes de Energia Renovável..."></textarea>
            </div>
             <div class="form-group">
                <label for="reportAuthorInput">Autor(es) (opcional):</label>
                <input type="text" id="reportAuthorInput" placeholder="Seu nome ou nomes dos autores">
            </div>
            <div class="button-group">
                <button id="btnGenerateReport"><i class="fa-solid fa-book-journal-whills"></i> Gerar Estrutura do Relatório</button>
                <button id="btnExportReportPdf" style="display:none;"><i class="fa-solid fa-file-pdf"></i> Exportar Relatório para PDF</button>
            </div>
            <div id="reportContentContainer" style="display:none;">
                <h3>Estrutura do Relatório Gerada:</h3>
                <div id="generatedReportContent"></div>
            </div>
        </div>


        <div id="searchAiSection" class="generator-section">
            <h2><i class="fa-solid fa-magnifying-glass"></i> Pesquisa com IA</h2>
            <textarea id="searchInput" placeholder="O que deseja pesquisar?"></textarea>
            <div class="button-group">
                <button id="btnSearchAI"><i class="fa-solid fa-paper-plane"></i> Pesquisar</button>
                <button id="btnClearSearch" style="display:none;"><i class="fa-solid fa-eraser"></i> Limpar</button>
                <button id="btnExportSearchPdf" style="display:none;"><i class="fa-solid fa-file-pdf"></i> Exportar Pesquisa para PDF</button>
            </div>
            <div id="searchResultsContainer" style="display:none;">
                <h3>Resultados da Pesquisa:</h3>
                <div id="searchResultsText"></div>
            </div>
        </div>

        <div id="radimakChatSection" class="generator-section">
            <h2><i class="fa-solid fa-robot"></i> Radimak Chat</h2>
            <div id="chatMessagesContainer" style="height: 300px; overflow-y: auto; border: 1px solid var(--border-color); padding: 10px; margin-bottom: 10px; background-color: var(--dark-background); border-radius: 6px;">
                </div>
            <textarea id="chatInput" placeholder="Escreva a sua dúvida ou mensagem para o Radimak..." style="min-height: 50px;"></textarea>
            <div class="button-group">
                <button id="btnSendChatMessage"><i class="fa-solid fa-paper-plane"></i> Enviar Mensagem</button>
            </div>
        </div>
        
        <div class="loading-indicator" id="loadingIndicator">Aguarde, a contactar a API Gemini...</div>
    </div>

    <script>
        // API Keys
        const userProvidedApiKey = "AIzaSyDxcxVmGPBbg7mJ6_cmMDkHrDpbx3Lspik"; 
        const geminiFlashApiKey = userProvidedApiKey; 
        const imagenApiKey = userProvidedApiKey; 
        const ttsApiKey = userProvidedApiKey; 

        const availableVoices = [
            { name: "Zephyr", value: "Zephyr" }, { name: "Puck", value: "Puck" },
            { name: "Charon", value: "Charon" }, { name: "Kore", value: "Kore" },
            { name: "Alnilam", value: "Alnilam" }, { name: "Sadachbia", value: "Sadachbia" },
            { name: "Leda", value: "Leda" } 
        ];
        
        const conteudosPorMateriaAno = {
            "Matemática": {
                "6": ["Números Naturais e Operações Fundamentais", "Múltiplos e Divisores (MMC e MDC)", "Frações: Conceitos e Operações", "Números Decimais e Operações", "Porcentagem Básica", "Geometria: Figuras Planas e Sólidos Geométricos", "Medidas de Comprimento, Massa, Capacidade e Tempo", "Introdução à Álgebra (sentenças matemáticas)"],
                "7": ["Números Inteiros: Operações e Ordenação", "Números Racionais: Frações e Decimais (positivos e negativos)", "Equações de 1º Grau com uma Incógnita", "Sistemas de Equações de 1º Grau (método da substituição)", "Razão e Proporção", "Regra de Três Simples e Composta", "Porcentagem e Juros Simples", "Ângulos e suas Classificações, Ângulos Opostos pelo Vértice", "Polígonos: Classificação, Propriedades e Soma dos Ângulos Internos", "Área de Figuras Planas (quadrado, retângulo, triângulo, trapézio, losango, círculo)"],
                "8": ["Números Reais e Potenciação com Expoente Inteiro e Fracionário", "Radiciação e suas Propriedades", "Produtos Notáveis e Fatoração Algébrica", "Sistemas de Equações de 1º Grau com Duas Incógnitas (método da adição)", "Equações de 2º Grau Incompletas", "Teorema de Pitágoras e suas aplicações", "Semelhança de Triângulos e Teorema de Tales", "Volume de Prismas e Cilindros", "Estatística: Média, Moda e Mediana", "Noções de Probabilidade"],
                "9": ["Potenciação e Radiciação (revisão e aprofundamento)", "Função Afim (1º Grau): Gráfico, Coeficientes e Raiz", "Função Quadrática (2º Grau): Gráfico, Vértice e Raízes (Fórmula de Bhaskara)", "Equações de 2º Grau Completas", "Relações Métricas no Triângulo Retângulo (além de Pitágoras)", "Trigonometria no Triângulo Retângulo (seno, cosseno, tangente de 30º, 45º, 60º)", "Circunferência e Círculo: Comprimento e Área", "Semelhança de Figuras Geométricas (polígonos e sólidos)", "Juros Compostos", "Estatística: Desvio Padrão e Variância (introdução)"]
            },
            "Português": { 
                "6": ["Interpretação de Textos Diversos", "Gêneros: Conto, Fábula, Notícia, Poema", "Substantivos", "Adjetivos", "Artigos", "Pronomes Pessoais", "Verbos (Modo Indicativo)", "Ortografia Básica", "Pontuação"],
                "7": ["Interpretação Textual Avançada", "Gêneros: Crônica, Reportagem, Entrevista", "Pronomes (Possessivos, Demonstrativos, Indefinidos)", "Advérbios", "Preposições", "Conjunções Coordenativas", "Verbos (Modo Subjuntivo)", "Concordância Nominal"],
                "8": ["Análise Crítica de Textos", "Gêneros: Artigo de Opinião, Resenha, Texto Teatral", "Vozes Verbais", "Conjunções Subordinativas", "Período Composto (Coordenação e Subordinação)", "Concordância Verbal", "Regência (casos simples)"],
                "9": ["Análise de Discurso", "Gêneros: Editorial, Manifesto, Debate", "Funções da Linguagem", "Variação Linguística", "Sintaxe do Período Composto (aprofundamento)", "Pontuação Expressiva", "Intertextualidade", "Literatura Brasileira (movimentos)"]
            },
            "Ciências": { 
                "6": ["Universo e Sistema Solar", "Planeta Terra", "Água, Solo e Ar", "Seres Vivos (características, reinos)", "Cadeias Alimentares"],
                "7": ["Máquinas Simples", "Energia (fontes, transformações)", "Calor e Temperatura", "Som e Luz", "Ecossistemas Brasileiros", "Relações Ecológicas", "Impactos Ambientais"],
                "8": ["Corpo Humano (células, tecidos, órgãos, sistemas)", "Sistemas: Digestório, Respiratório, Circulatório, Excretor, Nervoso, Locomotor", "Reprodução Humana", "Saúde e Prevenção"],
                "9": ["Genética (hereditariedade, DNA)", "Evolução das Espécies", "Química (matéria, átomos, moléculas, tabela periódica)", "Misturas", "Reações Químicas", "Física (movimento, força, Leis de Newton)"]
            },
            "História": { 
                "6": ["O que é História", "Pré-História", "Mesopotâmia e Egito", "Grécia Antiga", "Roma Antiga"],
                "7": ["Europa Feudal", "Império Bizantino e Islamismo", "Cruzadas", "Renascimento Comercial e Urbano", "Grandes Navegações", "Povos Indígenas da América"],
                "8": ["Iluminismo", "Revolução Francesa", "Revolução Industrial", "Independência dos EUA", "Período Napoleônico", "Independências na América Latina", "Brasil Imperial (1º Reinado, Regências)"],
                "9": ["Brasil Imperial (2º Reinado)", "República Velha no Brasil", "1ª Guerra Mundial", "Revolução Russa", "Crise de 1929", "2ª Guerra Mundial", "Guerra Fria"]
            },
            "Geografia": { 
                "6": ["Espaço Geográfico", "Orientação e Localização", "Cartografia", "Planeta Terra (movimentos, climas)", "Relevo, Hidrografia, Vegetação do Brasil", "População Brasileira"],
                "7": ["Formação Territorial do Brasil", "Regiões Brasileiras", "Urbanização Brasileira", "Atividades Econômicas no Brasil", "Recursos Naturais do Brasil"],
                "8": ["Globalização e Blocos Econômicos", "Continentes (América, África)", "Conflitos Mundiais", "Desenvolvimento e Subdesenvolvimento", "Questões Ambientais Globais"],
                "9": ["Europa (aspectos físicos, UE)", "Ásia (potências regionais)", "Oceania e Regiões Polares", "Redes Geográficas", "Brasil no Contexto Global"]
            },
            "Inglês": {
                "6": ["Greetings and Farewells", "Alphabet and Numbers (1-20)", "Colors", "Classroom Objects", "Family Members (basic)", "Verb 'to be' (am, is, are - affirmative, negative, interrogative)", "Simple Commands", "Animals (common pets and farm animals)"],
                "7": ["Present Simple (daily routines, habits)", "Question Words (What, Who, Where, When, Why, How)", "Prepositions of Place (in, on, under, next to, between)", "Describing People (simple adjectives: tall, short, happy)", "Can/Can't (ability)", "Food and Drinks (common items)", "Telling Time (o'clock, half past)", "Days of the Week, Months of the Year"],
                "8": ["Present Continuous (actions happening now)", "Past Simple (verb 'to be' - was, were)", "Past Simple (regular verbs - affirmative)", "Comparatives and Superlatives (simple adjectives)", "Object Pronouns (me, you, him, her, it, us, them)", "Likes and Dislikes (I like, I don't like + verb-ing)", "Sports and Hobbies"],
                "9": ["Past Simple (irregular verbs - common ones)", "Future with 'will' and 'going to'", "Modal Verbs (should, must, may - basic usage)", "Adverbs of Frequency (always, sometimes, never)", "Countable and Uncountable Nouns (some, any)", "Making Suggestions (Let's..., How about...?)", "Travel and Transportation"]
            },
            "Espanhol": { 
                "6": ["Saludos y Despedidas", "Alfabeto y Números (1-20)", "Colores", "Objetos de la Clase", "Mi Familia (básico)", "Verbo 'ser' y 'estar' (presente - formas básicas)", "Mandatos Simples", "Animales (comunes)"],
                "7": ["Presente de Indicativo (rutinas diarias)", "Interrogativos (Qué, Quién, Dónde, Cuándo, Por qué, Cómo)", "Preposiciones de Lugar", "Describir Personas (adjetivos simples)", "Poder (puedo, puedes)", "Comida y Bebida", "Decir la Hora", "Días de la Semana, Meses"],
                "8": ["Presente Continuo (estar + gerundio)", "Pretérito Imperfecto (verbos ser, estar, ir)", "Pretérito Perfecto Simple (verbos regulares)", "Comparativos y Superlativos", "Pronombres de Objeto Directo", "Gustar y Encantar", "Deportes y Aficiones"],
                "9": ["Pretérito Perfecto Simple (verbos irregulares comunes)", "Futuro Simple", "Verbos Modales (deber, tener que, poder - básico)", "Adverbios de Frecuencia", "Sustantivos Contables e Incontables (algunos, ningunos)", "Hacer Sugerencias", "Viajes y Transporte"]
            },
            "Filosofia": {
                 "6": ["O que é perguntar? A curiosidade", "O que eu vejo? Percepção e realidade (sentidos)", "Quem sou eu? Identidade e diferenças", "O que é ser amigo? Amizade e convivência", "Certo e Errado: noções iniciais de ética"],
                "7": ["Mitos e suas explicações do mundo", "O que é pensar? Introdução à lógica e ao raciocínio", "O que é a beleza? Noções de estética", "O que é a felicidade? Diferentes visões", "Liberdade e Escolha"],
                "8": ["O que é Filosofia? Origens na Grécia Antiga", "Sócrates: Conhece-te a ti mesmo e o método socrático", "Platão: O mundo das ideias e a Alegoria da Caverna", "Aristóteles: A busca pelo conhecimento e a ética", "O que é o conhecimento? Diferentes formas de saber"],
                "9": ["Filosofia Política: O que é justiça? O que é o Estado?", "Ética e Moral: Dilemas morais contemporâneos", "Existencialismo (introdução): Liberdade e responsabilidade", "Filosofia da Ciência: O que é ciência? Método científico", "Grandes Pensadores e suas contribuições (breve panorama)"]
            },
            "Educação Física": {
                "6": ["Jogos Cooperativos e Competitivos", "Brincadeiras de Roda e Cantigas", "Fundamentos de Esportes de Invasão (futsal, handebol - passe, drible, chute/arremesso)", "Ginástica Rítmica e Artística (elementos básicos)", "Atividades Rítmicas e Expressivas (danças simples)"],
                "7": ["Esportes de Rede/Parede (vôlei, badminton - fundamentos)", "Esportes de Marca (atletismo - corrida, saltos, arremessos básicos)", "Lutas (judô, capoeira - introdução, movimentos básicos e respeito)", "Primeiros Socorros (noções básicas em caso de acidentes na prática esportiva)", "Saúde e Qualidade de Vida: Alimentação e Atividade Física"],
                "8": ["Esportes Técnico-Combinatórios (ginástica, nado sincronizado - apreciação e prática de elementos)", "Esportes de Campo e Taco (beisebol/softbol adaptado, críquete adaptado - introdução)", "Dança (ritmos brasileiros e internacionais - criação e apreciação)", "Práticas Corporais de Aventura na Natureza (conceitos, segurança - ex: trilha, slackline adaptado)", "Doping e Fair Play no Esporte"],
                "9": ["Organização de Eventos Esportivos e Recreativos na Escola", "Análise Crítica da Mídia Esportiva", "Esportes Adaptados e Inclusão", "Planejamento de Treino Físico (noções de carga, intensidade, volume)", "História dos Jogos Olímpicos e Paralímpicos"]
            },
            "Arte": {
                "6": ["Elementos da Linguagem Visual (ponto, linha, forma, cor, textura, volume)", "Cores Primárias, Secundárias e Terciárias", "Técnicas de Desenho (luz e sombra, perspectiva básica)", "Modelagem (argila, massa de modelar)", "Arte Rupestre e Arte Indígena Brasileira"],
                "7": ["Arte Egípcia e Grega (arquitetura, escultura, pintura)", "Arte Romana (mosaicos, retratos)", "Arte Medieval (vitrais, iluminuras, arquitetura gótica e românica)", "Gravura (isogravura, xilogravura básica)", "Teatro de Sombras e Marionetes"],
                "8": ["Renascimento Cultural (principais artistas e características)", "Barroco (Europa e Brasil)", "Fotografia (história e técnicas básicas de composição)", "Arte Abstrata e Figurativa", "Instalações Artísticas e Intervenções Urbanas (conceito)"],
                "9": ["Movimentos Artísticos do Século XIX (Impressionismo, Pós-Impressionismo)", "Vanguardas Europeias do Século XX (Cubismo, Surrealismo, Expressionismo)", "Arte Moderna e Contemporânea no Brasil (Semana de 22, artistas relevantes)", "Design Gráfico (cartazes, logotipos)", "Arte Digital e Novas Mídias"]
            }
        };

        // Elementos do DOM
        let activitySpecificContentSelect;
        let slideTopicInput, slideNumSlidesInput, slideIncludeImagesCheckbox, btnGenerateSlide, slideContentContainer, generatedSlideContent, btnExportSlidePdf, btnExportSlidePptx;
        let reportTopicInput, reportAuthorInput, btnGenerateReport, reportContentContainer, generatedReportContent, btnExportReportPdf;
        let ideaTopicInput, btnGenerateIdeas, ideasDisplayContainer, generatedIdeasText, btnExportIdeasPdf;
        let chatInput, btnSendChatMessage, chatMessagesContainer;
        // Elementos para Gerador de Receitas
        let recipeIngredients, recipeCuisineType, recipeDifficulty, btnGenerateRecipe, recipeDisplayContainer, generatedRecipeText, btnExportRecipePdf, btnPlayRecipe;


        window.onload = function() {
            errorMessageElement = document.getElementById('errorMessage'); 
            loadingIndicator = document.getElementById('loadingIndicator');
            
            btnRecordVoice = document.getElementById('btnRecordVoice');
            voiceChatResponseContainer = document.getElementById('voiceChatResponseContainer');
            voiceChatResponseText = document.getElementById('voiceChatResponseText');
            talkAiVoiceSelect = document.getElementById('talkAiVoiceSelect');

            fileInput = document.getElementById('fileInput');
            btnProcessFileToSpeech = document.getElementById('btnProcessFileToSpeech');
            btnExportPodcastScriptPdf = document.getElementById('btnExportPodcastScriptPdf'); 
            podcastScriptDisplayContainer = document.getElementById('podcastScriptDisplayContainer');
            generatedPodcastScriptText = document.getElementById('generatedPodcastScriptText');
            
            ttsInputText = document.getElementById('ttsInputText');
            btnGenerateSpeechFromText = document.getElementById('btnGenerateSpeechFromText'); 
            audioPlayer = document.getElementById('audioPlayer');
            audioPlayerContainer = document.getElementById('audioPlayerContainer');
            
            imagePromptTextarea = document.getElementById('imagePrompt');
            btnGenerateImageFromText = document.getElementById('btnGenerateImageFromText');
            aiGeneratedImageElement = document.getElementById('aiGeneratedImage');
            aiImagePlaceholder = document.getElementById('aiImagePlaceholder');
            aiGeneratedImageContainer = document.getElementById('aiGeneratedImageContainer');
            btnDownloadAiImage = document.getElementById('btnDownloadAiImage');
            btnDeleteAiImage = document.getElementById('btnDeleteAiImage');

            scriptPromptTextarea = document.getElementById('scriptPrompt');
            btnGenerateScript = document.getElementById('btnGenerateScript');
            scriptDisplayContainer = document.getElementById('scriptDisplayContainer');
            generatedScriptText = document.getElementById('generatedScriptText');
            btnPlayScript = document.getElementById('btnPlayScript');
            scriptVoiceSelect = document.getElementById('scriptVoiceSelect');

            activityYearSelect = document.getElementById('activityYearSelect');
            activitySubjectSelect = document.getElementById('activitySubjectSelect');
            activitySpecificContentSelect = document.getElementById('activitySpecificContentSelect'); 
            activityNumQuestionsSelect = document.getElementById('activityNumQuestionsSelect');
            btnGenerateActivity = document.getElementById('btnGenerateActivity');
            activityDisplayContainer = document.getElementById('activityDisplayContainer');
            generatedActivityText = document.getElementById('generatedActivityText');
            btnExportActivityPdf = document.getElementById('btnExportActivityPdf');

            searchInput = document.getElementById('searchInput');
            btnSearchAI = document.getElementById('btnSearchAI');
            searchResultsContainer = document.getElementById('searchResultsContainer');
            searchResultsText = document.getElementById('searchResultsText');
            btnClearSearch = document.getElementById('btnClearSearch');
            
            sourceTextToTranslate = document.getElementById('sourceTextToTranslate');
            sourceLanguageSelect = document.getElementById('sourceLanguageSelect');
            targetLanguageSelect = document.getElementById('targetLanguageSelect');
            btnTranslateText = document.getElementById('btnTranslateText');
            translatedTextContainer = document.getElementById('translatedTextContainer');
            translatedTextOutput = document.getElementById('translatedTextOutput');
            btnPlayTranslatedText = document.getElementById('btnPlayTranslatedText');
            translatorVoiceSelect = document.getElementById('translatorVoiceSelect');

            slideTopicInput = document.getElementById('slideTopicInput');
            slideNumSlidesInput = document.getElementById('slideNumSlidesInput');
            slideIncludeImagesCheckbox = document.getElementById('slideIncludeImagesCheckbox');
            btnGenerateSlide = document.getElementById('btnGenerateSlide');
            slideContentContainer = document.getElementById('slideContentContainer');
            generatedSlideContent = document.getElementById('generatedSlideContent');
            btnExportSlidePdf = document.getElementById('btnExportSlidePdf');
            btnExportSlidePptx = document.getElementById('btnExportSlidePptx');


            reportTopicInput = document.getElementById('reportTopicInput');
            reportAuthorInput = document.getElementById('reportAuthorInput');
            btnGenerateReport = document.getElementById('btnGenerateReport');
            reportContentContainer = document.getElementById('reportContentContainer');
            generatedReportContent = document.getElementById('generatedReportContent');
            btnExportReportPdf = document.getElementById('btnExportReportPdf');
            
            chatInput = document.getElementById('chatInput');
            btnSendChatMessage = document.getElementById('btnSendChatMessage');
            chatMessagesContainer = document.getElementById('chatMessagesContainer');

            ideaTopicInput = document.getElementById('ideaTopicInput');
            btnGenerateIdeas = document.getElementById('btnGenerateIdeas');
            ideasDisplayContainer = document.getElementById('ideasDisplayContainer');
            generatedIdeasText = document.getElementById('generatedIdeasText');
            btnExportIdeasPdf = document.getElementById('btnExportIdeasPdf');

            // Gerador de Receitas
            recipeIngredients = document.getElementById('recipeIngredients');
            recipeCuisineType = document.getElementById('recipeCuisineType');
            recipeDifficulty = document.getElementById('recipeDifficulty');
            btnGenerateRecipe = document.getElementById('btnGenerateRecipe');
            recipeDisplayContainer = document.getElementById('recipeDisplayContainer');
            generatedRecipeText = document.getElementById('generatedRecipeText');
            btnExportRecipePdf = document.getElementById('btnExportRecipePdf');
            btnPlayRecipe = document.getElementById('btnPlayRecipe');


            populateVoiceSelectors();
            populateActivitySubjects(); 
            updateSpecificContentOptions(); 
            
            // Navegação SPA com Menu Lateral
            navLinks = document.querySelectorAll('.side-menu .tool-link'); 
            generatorSections = document.querySelectorAll('.generator-section');
            const mainMenuButton = document.getElementById('mainMenuButton');
            const closeMenuButton = document.getElementById('closeMenuButton');
            const sideMenu = document.getElementById('sideMenu');
            const mainContentArea = document.getElementById('mainContentArea');

            mainMenuButton.addEventListener('click', () => {
                sideMenu.style.width = '280px'; 
            });

            closeMenuButton.addEventListener('click', () => {
                sideMenu.style.width = '0';
            });


            navLinks.forEach(link => {
                link.addEventListener('click', function(event) {
                    event.preventDefault();
                    const targetId = this.getAttribute('data-target');
                    navLinks.forEach(navLink => navLink.classList.remove('active')); 
                    this.classList.add('active'); 
                    
                    generatorSections.forEach(section => {
                        section.style.display = section.id === targetId ? 'block' : 'none';
                    });
                    clearErrorMessage(); 
                    audioPlayerContainer.style.display = 'none'; 
                    sideMenu.style.width = '0'; 
                });
            });
             if (generatorSections.length > 0 && document.getElementById('talkToAiSection')) {
                document.getElementById('talkToAiSection').style.display = 'block';
                 const activeLink = document.querySelector('.tool-link[data-target="talkToAiSection"]');
                 if(activeLink) activeLink.classList.add('active');
            }


            // Event Listeners
            btnGenerateImageFromText.addEventListener('click', gerarImagemComIA);
            btnDownloadAiImage.addEventListener('click', baixarImagemGeradaIA);
            btnDeleteAiImage.addEventListener('click', apagarImagemGeradaIA);
            btnGenerateSpeechFromText.addEventListener('click', () => { 
                 const textToSpeak = ttsInputText.value.trim();
                 const selectedVoice = document.getElementById('ttsVoiceSelect').value;
                 if (textToSpeak) {
                    gerarFalaComIA(textToSpeak, "Texto Introduzido", false, selectedVoice); 
                 } else {
                    displayErrorMessage("Por favor, introduza o texto que deseja converter em fala.");
                 }
            });
            btnProcessFileToSpeech.addEventListener('click', processFileToSpeech);
            btnRecordVoice.addEventListener('click', toggleVoiceRecording);
            btnGenerateScript.addEventListener('click', gerarGuiaoHistoria);
            btnPlayScript.addEventListener('click', () => {
                const scriptContent = generatedScriptText.textContent;
                const selectedVoice = scriptVoiceSelect.value;
                if (scriptContent) {
                    gerarFalaComIA(scriptContent, "Guião/História Gerada", false, selectedVoice); 
                }
            });
            btnGenerateActivity.addEventListener('click', gerarAtividadesComIA);
            activityYearSelect.addEventListener('change', updateSpecificContentOptions);
            activitySubjectSelect.addEventListener('change', updateSpecificContentOptions);

            btnSearchAI.addEventListener('click', pesquisarComIA);
            btnClearSearch.addEventListener('click', () => {
                searchResultsText.textContent = '';
                searchResultsContainer.style.display = 'none';
                btnClearSearch.style.display = 'none';
                document.getElementById('btnExportSearchPdf').style.display = 'none';
            });
             btnExportPodcastScriptPdf.addEventListener('click', () => exportTextToPdf(generatedPodcastScriptText.textContent, "guiao_podcast.pdf"));
             btnExportActivityPdf.addEventListener('click', () => exportTextToPdf(generatedActivityText.textContent, "atividades_geradas.pdf"));
             btnTranslateText.addEventListener('click', translateTextWithAI);
             btnPlayTranslatedText.addEventListener('click', () => {
                const translatedContent = translatedTextOutput.textContent;
                const selectedVoice = translatorVoiceSelect.value;
                if (translatedContent) {
                    gerarFalaComIA(translatedContent, "Texto Traduzido", false, selectedVoice);
                }
             });
            btnGenerateSlide.addEventListener('click', gerarSlidesComIA);
            btnExportSlidePdf.addEventListener('click', () => exportTextToPdf(generatedSlideContent.innerText, "apresentacao_slides.pdf")); 
            btnExportSlidePptx.addEventListener('click', exportSlidesToPptx);
            btnExportReportPdf.addEventListener('click', () => exportTextToPdf(generatedReportContent.innerText, "relatorio_gerado.pdf"));
            btnGenerateReport.addEventListener('click', gerarRelatorioComIA);
            btnSendChatMessage.addEventListener('click', enviarMensagemChatRadimak);
            document.getElementById('btnExportSearchPdf').addEventListener('click', () => exportTextToPdf(searchResultsText.textContent, "pesquisa_ia.pdf"));
            btnGenerateIdeas.addEventListener('click', gerarIdeiasComIA);
            btnExportIdeasPdf.addEventListener('click', () => exportTextToPdf(generatedIdeasText.textContent, "ideias_geradas.pdf"));
            btnGenerateRecipe.addEventListener('click', gerarReceitaComIA);
            btnExportRecipePdf.addEventListener('click', () => exportTextToPdf(generatedRecipeText.textContent, "receita_gerada.pdf"));
            btnPlayRecipe.addEventListener('click', () => {
                const recipeContent = generatedRecipeText.textContent;
                if(recipeContent) gerarFalaComIA(recipeContent, "Receita Gerada", false, "Zephyr"); 
            });


            audioPlayer.onerror = function(e) {
                console.error("Erro no elemento de áudio:", e);
                let specificError = "Erro desconhecido ao carregar o áudio.";
                if (audioPlayer.error) {
                    switch (audioPlayer.error.code) {
                        case MediaError.MEDIA_ERR_ABORTED: specificError = "A reprodução do áudio foi abortada."; break;
                        case MediaError.MEDIA_ERR_NETWORK: specificError = "Ocorreu um erro de rede ao carregar o áudio."; break;
                        case MediaError.MEDIA_ERR_DECODE: specificError = "Ocorreu um erro ao descodificar o áudio. O formato pode ser inválido ou não suportado."; break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: specificError = "O formato do áudio não é suportado ou a fonte não pôde ser encontrada."; break;
                        default: specificError = `Ocorreu um erro ao carregar o áudio (código: ${audioPlayer.error.code}).`;
                    }
                }
                displayErrorMessage(specificError + ` (Tipo MIME tentado: ${lastAttemptedMimeType})`);
                audioPlayerContainer.style.display = 'none';
            };
        };

        function populateVoiceSelectors() {
            const selectors = [
                { id: 'talkAiVoiceSelect', default: 'Charon' },
                { id: 'podcastSpeaker1Voice', default: 'Charon' },
                { id: 'podcastSpeaker2Voice', default: 'Kore' },
                { id: 'ttsVoiceSelect', default: 'Zephyr' },
                { id: 'scriptVoiceSelect', default: 'Zephyr' },
                { id: 'translatorVoiceSelect', default: 'Zephyr'} 
            ];

            selectors.forEach(selInfo => {
                const selectElement = document.getElementById(selInfo.id);
                if (selectElement) {
                    availableVoices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.value;
                        option.textContent = voice.name;
                        if (voice.value === selInfo.default) {
                            option.selected = true;
                        }
                        selectElement.appendChild(option);
                    });
                }
            });
        }
        
        function populateActivitySubjects() {
            const subjects = Object.keys(conteudosPorMateriaAno);
            activitySubjectSelect.innerHTML = ''; 
            subjects.forEach(subject => {
                const option = document.createElement('option');
                option.value = subject;
                option.textContent = subject;
                activitySubjectSelect.appendChild(option);
            });
        }

        function updateSpecificContentOptions() {
            const selectedYear = activityYearSelect.value;
            const selectedSubject = activitySubjectSelect.value;
            activitySpecificContentSelect.innerHTML = ''; 

            if (conteudosPorMateriaAno[selectedSubject] && conteudosPorMateriaAno[selectedSubject][selectedYear]) {
                const contents = conteudosPorMateriaAno[selectedSubject][selectedYear];
                contents.forEach(content => {
                    const option = document.createElement('option');
                    option.value = content;
                    option.textContent = content;
                    activitySpecificContentSelect.appendChild(option);
                });
            } else {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "Nenhum conteúdo específico disponível";
                option.disabled = true;
                activitySpecificContentSelect.appendChild(option);
            }
        }


        function displayErrorMessage(message) {
            errorMessageElement.textContent = message;
            errorMessageElement.style.display = 'block';
            errorMessageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function clearErrorMessage() {
            errorMessageElement.textContent = '';
            errorMessageElement.style.display = 'none';
        }

        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(new Error(`Erro ao ler o ficheiro: ${error.message}`));
                reader.readAsDataURL(file);
            });
        }
        
        function readFileAsText(file) {
             return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(new Error(`Erro ao ler o ficheiro de texto: ${error.message}`));
                reader.readAsText(file);
            });
        }

        async function toggleVoiceRecording() {
             console.log("toggleVoiceRecording - Início. mediaRecorder:", mediaRecorder, "Estado:", mediaRecorder ? mediaRecorder.state : "N/A");
            if (mediaRecorder && mediaRecorder.state === "recording") {
                console.log("toggleVoiceRecording - A parar gravação.");
                if (mediaRecorder) mediaRecorder.stop(); 
                else console.warn("MediaRecorder não estava definido ao tentar parar.");
            } else {
                console.log("toggleVoiceRecording - A iniciar nova gravação.");
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' }); 
                    audioChunks = []; 
                    mediaRecorder.ondataavailable = event => {
                        console.log("toggleVoiceRecording - ondataavailable");
                        audioChunks.push(event.data);
                    };
                    mediaRecorder.onstart = () => { 
                        console.log("toggleVoiceRecording - onstart");
                        btnRecordVoice.innerHTML = '<i class="fa-solid fa-stop"></i> Parar Gravação';
                        btnRecordVoice.classList.add("recording");
                        loadingIndicator.style.display = 'none'; 
                        clearErrorMessage();
                        voiceChatResponseContainer.style.display = 'none';
                        audioPlayerContainer.style.display = 'none'; 
                    };
                    mediaRecorder.onstop = async () => {
                        console.log("toggleVoiceRecording - onstop");
                        btnRecordVoice.innerHTML = '<i class="fa-solid fa-microphone"></i> Gravar Voz';
                        btnRecordVoice.classList.remove("recording");
                        loadingIndicator.textContent = "A processar áudio gravado...";
                        loadingIndicator.style.display = 'block';
                        const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
                        audioChunks = []; 
                        stream.getTracks().forEach(track => track.stop()); 
                        try {
                            const base64Audio = await readFileAsBase64(audioBlob);
                            await sendAudioToGemini(base64Audio, mediaRecorder.mimeType);
                        } catch (error) {
                            displayErrorMessage(`Erro ao processar áudio gravado: ${error.message}`);
                        } finally {
                            loadingIndicator.style.display = 'none';
                        }
                    };
                    mediaRecorder.start();
                     console.log("toggleVoiceRecording - mediaRecorder.start() chamado.");
                } catch (error) {
                    console.error("Erro em toggleVoiceRecording (else):", error);
                    displayErrorMessage("Não foi possível aceder ao microfone. Verifique as permissões.");
                    btnRecordVoice.innerHTML = '<i class="fa-solid fa-microphone"></i> Gravar Voz';
                    btnRecordVoice.classList.remove("recording");
                }
            }
        }

        async function sendAudioToGemini(base64AudioData, mimeType) {
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            loadingIndicator.textContent = "A IA está a pensar...";
            loadingIndicator.style.display = 'block';
            const payload = { contents: [{ role: "user", parts: [ { inlineData: { mimeType: mimeType, data: base64AudioData } } ] }] };
            try {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao processar áudio (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const aiResponseText = result.candidates[0].content.parts[0].text;
                    voiceChatResponseText.textContent = aiResponseText;
                    voiceChatResponseContainer.style.display = 'block';
                    const selectedVoice = talkAiVoiceSelect.value;
                    await gerarFalaComIA(aiResponseText, "Resposta da IA", false, selectedVoice); 
                } else {
                    throw new Error("Não foi possível obter uma resposta de texto da IA para o áudio enviado.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        async function getSummaryForTTS(base64Data, mimeType, fileType) {
            if (!geminiFlashApiKey) throw new Error("API key para Gemini Flash não configurada.");
            
            let promptText = "";
            let maxTokens = 2000; 
            if (fileType === "image") {
                promptText = "Crie um resumo detalhado desta imagem, com informação suficiente para gerar um diálogo de podcast com cerca de 2-3 minutos de duração. Destaque os elementos visuais principais, a atmosfera geral e em quaisquer textos visíveis. Seja descritivo e envolvente.";
                maxTokens = 700; 
            } else if (fileType === "pdf") {
                promptText = "Crie um resumo detalhado e abrangente deste documento PDF, com informação suficiente para gerar um diálogo de podcast com aproximadamente 7 minutos de duração. Foque-se nas ideias principais, argumentos, exemplos e conclusões, omitindo apenas detalhes menores ou informação redundante. O objetivo é ter material rico para uma discussão entre duas vozes.";
                maxTokens = 3500; 
            } else if (fileType === "text") {
                 promptText = "Crie um resumo detalhado e abrangente deste texto, com informação suficiente para gerar um diálogo de podcast com aproximadamente 7 minutos de duração. Foque-se nas ideias principais, argumentos, exemplos e conclusões. O objetivo é ter material rico para uma discussão entre duas vozes.";
                 maxTokens = 3500; 
            }

            const payload = {
                contents: [{ role: "user", parts: [{ text: promptText }, { inlineData: { mimeType: mimeType, data: base64Data } }] }],
                generationConfig: { maxOutputTokens: maxTokens, temperature: 0.6 } 
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
            loadingIndicator.textContent = `A gerar resumo de ${fileType}...`;
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Erro ao obter resumo de ${fileType} (${response.status}): ${errorData?.error?.message || response.statusText}`);
            }
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                return result.candidates[0].content.parts[0].text;
            }
            throw new Error(`Não foi possível extrair o resumo de ${fileType} da API.`);
        }

        async function generateDialogueFromSummary(summaryText) {
            if (!geminiFlashApiKey) throw new Error("API key para Gemini Flash (geração de diálogo) não configurada.");
            loadingIndicator.textContent = "A criar guião de diálogo para o podcast...";
            
            const prompt = `Com base no seguinte resumo detalhado, crie um guião de diálogo extenso e envolvente (visando aproximadamente 1000-1500 palavras, o que pode equivaler a cerca de 7-10 minutos de fala) entre duas pessoas (identificadas como "Speaker 1:" e "Speaker 2:") para um podcast. O diálogo deve explorar os pontos principais do resumo de forma natural, aprofundada e conversacional, como se fosse uma discussão real. Formate o guião claramente com "Speaker 1:" e "Speaker 2:" antes de cada fala. Não adicione nenhuma introdução ou conclusão ao diálogo, apenas as falas dos speakers. Resumo:\n\n${summaryText}`;
            
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: { maxOutputTokens: 2500, temperature: 0.75 } 
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Erro ao gerar diálogo (${response.status}): ${errorData?.error?.message || response.statusText}`);
            }
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                generatedPodcastScriptText.textContent = result.candidates[0].content.parts[0].text; 
                podcastScriptDisplayContainer.style.display = 'block';
                btnExportPodcastScriptPdf.style.display = 'inline-flex'; 
                return result.candidates[0].content.parts[0].text;
            }
            throw new Error("Não foi possível gerar o guião do diálogo a partir do resumo.");
        }


        async function processFileToSpeech() {
            const file = fileInput.files[0];
            if (!file) {
                displayErrorMessage("Por favor, selecione um ficheiro.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.style.display = 'block';
            audioPlayerContainer.style.display = 'none';
            podcastScriptDisplayContainer.style.display = 'none';
            btnExportPodcastScriptPdf.style.display = 'none'; 


            try {
                let summaryText = "";
                let fileDescriptionForTTS = file.name;
                let fileTypeForSummary = "";

                if (file.type.startsWith("image/")) {
                    fileTypeForSummary = "image";
                    const base64FileContent = await readFileAsBase64(file);
                    summaryText = await getSummaryForTTS(base64FileContent, file.type, fileTypeForSummary);
                    fileDescriptionForTTS = `Podcast sobre a imagem ${file.name}`;
                } else if (file.type === "application/pdf") {
                     fileTypeForSummary = "pdf";
                    const base64FileContent = await readFileAsBase64(file);
                    summaryText = await getSummaryForTTS(base64FileContent, "application/pdf", fileTypeForSummary);
                    fileDescriptionForTTS = `Podcast sobre o PDF ${file.name}`;
                } else if (file.type === "text/plain") {
                    fileTypeForSummary = "text"; 
                    const rawText = await readFileAsText(file); 
                    summaryText = await getSummaryForTTS(rawText, "text/plain", fileTypeForSummary); 
                    fileDescriptionForTTS = `Podcast sobre o ficheiro ${file.name}`;
                } else {
                    throw new Error(`Tipo de ficheiro não suportado: ${file.type}. Por favor, selecione uma imagem, PDF ou ficheiro .txt.`);
                }

                if (summaryText) {
                    const dialogueScript = await generateDialogueFromSummary(summaryText);
                    if (dialogueScript) {
                        await gerarFalaComIA(dialogueScript, fileDescriptionForTTS, true); 
                    } else {
                        throw new Error("Falha ao gerar o guião do diálogo.");
                    }
                } else {
                    throw new Error("Não foi possível extrair ou resumir conteúdo do ficheiro para conversão em fala.");
                }

            } catch (error) {
                console.error("Erro ao processar ficheiro para fala:", error);
                displayErrorMessage(`Erro ao processar ficheiro: ${error.message}`);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        async function gerarGuiaoHistoria() {
            const prompt = scriptPromptTextarea.value.trim();
            if (!prompt) {
                displayErrorMessage("Por favor, forneça um tema ou ideia para o guião/história.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A gerar guião/história...";
            loadingIndicator.style.display = 'block';
            scriptDisplayContainer.style.display = 'none';
            btnPlayScript.style.display = 'none';

            const generationPrompt = `Crie um guião curto ou uma história (aproximadamente 300-500 palavras) com base no seguinte: "${prompt}". Se for um guião, defina claramente os personagens e as suas falas (ex: PERSONAGEM: Fala.). Se for uma história, escreva uma narrativa envolvente.`;

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: generationPrompt }] }],
                    generationConfig: { temperature: 0.8, maxOutputTokens: 800 }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao gerar guião (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const script = result.candidates[0].content.parts[0].text;
                    generatedScriptText.textContent = script;
                    scriptDisplayContainer.style.display = 'block';
                    btnPlayScript.style.display = 'inline-flex'; 
                } else {
                    throw new Error("Não foi possível obter o guião/história da resposta da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        async function gerarAtividadesComIA() {
            const ano = activityYearSelect.value;
            const materia = activitySubjectSelect.value;
            const conteudo = activitySpecificContentSelect.value; 
            const tipoQuestao = document.getElementById('activityQuestionTypeSelect').value;
            const numQuestoes = activityNumQuestionsSelect.value;

            if (!conteudo) { 
                displayErrorMessage("Por favor, selecione o conteúdo específico para as atividades.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A gerar atividades...";
            loadingIndicator.style.display = 'block';
            activityDisplayContainer.style.display = 'none';
            btnExportActivityPdf.style.display = 'none';

            let tipoQuestaoPrompt = "";
            if (tipoQuestao === "Objetivas") {
                tipoQuestaoPrompt = "As questões devem ser primariamente objetivas (ex: múltipla escolha com 4 alternativas, verdadeiro ou falso).";
            } else if (tipoQuestao === "Subjetivas") {
                tipoQuestaoPrompt = "As questões devem ser primariamente subjetivas (ex: dissertativas curtas, resolução de problemas passo a passo, interpretação).";
            } else { // Ambas
                tipoQuestaoPrompt = "As questões devem ser variadas, incluindo tanto objetivas (ex: múltipla escolha, V/F) quanto subjetivas (ex: dissertativas curtas, problemas).";
            }

            const prompt = `Crie ${numQuestoes} questões de ${materia} para alunos do ${ano}º ano do Ensino Fundamental, focadas no seguinte conteúdo: "${conteudo}". ${tipoQuestaoPrompt} As questões devem ser claras e adequadas ao nível de ensino. Formate a saída de forma organizada, numerando cada questão. Se incluir questões de múltipla escolha, forneça 4 alternativas (A, B, C, D) e indique a resposta correta no final de cada questão objetiva entre parênteses, por exemplo: (Resposta: C).`;

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.6, maxOutputTokens: 2000 } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao gerar atividades (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const activities = result.candidates[0].content.parts[0].text;
                    generatedActivityText.textContent = activities;
                    activityDisplayContainer.style.display = 'block';
                    btnExportActivityPdf.style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter as atividades da resposta da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        async function pesquisarComIA() {
            const query = searchInput.value.trim();
            if (!query) {
                displayErrorMessage("Por favor, introduza um termo para pesquisar.");
                return;
            }
             if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A pesquisar...";
            loadingIndicator.style.display = 'block';
            searchResultsContainer.style.display = 'none';
            btnClearSearch.style.display = 'none';
            document.getElementById('btnExportSearchPdf').style.display = 'none';


            const prompt = `Forneça uma resposta detalhada e abrangente sobre "${query}". Se possível, estruture a resposta em secções ou tópicos para facilitar a leitura. O objetivo é obter informação completa sobre o assunto.`;
            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.5, maxOutputTokens: 2000 } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao pesquisar (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const searchResult = result.candidates[0].content.parts[0].text;
                    searchResultsText.textContent = searchResult;
                    searchResultsContainer.style.display = 'block';
                    btnClearSearch.style.display = 'inline-flex';
                    document.getElementById('btnExportSearchPdf').style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter resultados da pesquisa da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        async function translateTextWithAI() {
            const textToTranslate = sourceTextToTranslate.value.trim();
            const sourceLang = sourceLanguageSelect.value;
            const targetLang = targetLanguageSelect.value;

            if (!textToTranslate) {
                displayErrorMessage("Por favor, introduza o texto que deseja traduzir.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A traduzir texto...";
            loadingIndicator.style.display = 'block';
            translatedTextContainer.style.display = 'none';
            btnPlayTranslatedText.style.display = 'none';

            let translationPrompt = "";
            if (sourceLang === "auto") {
                translationPrompt = `Identifique a língua do seguinte texto e traduza-o para ${targetLanguageSelect.options[targetLanguageSelect.selectedIndex].text}:\n\n"${textToTranslate}"`;
            } else {
                translationPrompt = `Traduza o seguinte texto de ${sourceLanguageSelect.options[sourceLanguageSelect.selectedIndex].text} para ${targetLanguageSelect.options[targetLanguageSelect.selectedIndex].text}:\n\n"${textToTranslate}"`;
            }
            
            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: translationPrompt }] }],
                    generationConfig: { temperature: 0.3, maxOutputTokens: textToTranslate.length + 200 } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao traduzir (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const translatedText = result.candidates[0].content.parts[0].text;
                    translatedTextOutput.textContent = translatedText;
                    translatedTextContainer.style.display = 'block';
                    btnPlayTranslatedText.style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter a tradução da resposta da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        async function gerarSlidesComIA() {
            const topic = slideTopicInput.value.trim();
            const numSlides = slideNumSlidesInput.value;
            const includeImages = slideIncludeImagesCheckbox.checked;

            if (!topic) {
                displayErrorMessage("Por favor, defina o tema principal dos slides.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A gerar conteúdo dos slides...";
            loadingIndicator.style.display = 'block';
            slideContentContainer.style.display = 'none';
            btnExportSlidePdf.style.display = 'none';
            document.getElementById('btnExportSlidePptx').style.display = 'none';


            let imagePrompt = "";
            if (includeImages) {
                imagePrompt = "Para cada slide, sugira também uma imagem relevante descrevendo-a brevemente entre colchetes, por exemplo: [Descrição da imagem sugerida].";
            }

            const prompt = `Crie o conteúdo para uma apresentação de aproximadamente ${numSlides} slides sobre o tema: "${topic}". 
                Para cada slide, forneça um título claro e um texto conciso com os pontos principais. ${imagePrompt}
                Organize o conteúdo de forma lógica e progressiva. 
                Formato esperado para cada slide:
                --- SLIDE X ---
                TÍTULO DO SLIDE
                Conteúdo do slide...
                ${includeImages ? "Sugestão de Imagem: [Descrição da imagem]" : ""}
                --- FIM SLIDE X ---`;
            
            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.7, maxOutputTokens: 3000 } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao gerar slides (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const slideContent = result.candidates[0].content.parts[0].text;
                    generatedSlideContent.innerHTML = slideContent.replace(/--- SLIDE (\d+) ---/g, "<h3>Slide $1</h3>").replace(/--- FIM SLIDE \d+ ---/g, "<hr>"); 
                    slideContentContainer.style.display = 'block';
                    btnExportSlidePdf.style.display = 'inline-flex';
                    document.getElementById('btnExportSlidePptx').style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter o conteúdo dos slides da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        async function gerarRelatorioComIA() {
            const topic = reportTopicInput.value.trim();
            const author = reportAuthorInput.value.trim() || "Autor Desconhecido";

            if (!topic) {
                displayErrorMessage("Por favor, defina o tema do relatório.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A gerar estrutura do relatório...";
            loadingIndicator.style.display = 'block';
            reportContentContainer.style.display = 'none';
            btnExportReportPdf.style.display = 'none';
            
            const prompt = `Crie uma estrutura detalhada para um relatório sobre o tema "${topic}", com autoria de "${author}".
                O relatório deve incluir as seguintes secções bem definidas:
                1.  Capa: Com título do relatório, autor(es), e data (usar a data atual no formato DD/MM/AAAA).
                2.  Contracapa (opcional, pode ser uma página em branco ou com informações adicionais como nome da instituição, se aplicável - deixe um placeholder se não souber).
                3.  Sumário (apenas o título da secção, o conteúdo seria gerado após o desenvolvimento).
                4.  Introdução: Apresente o tema, a sua relevância, os objetivos do relatório e uma breve descrição da estrutura do trabalho.
                5.  Desenvolvimento: Divida esta secção em pelo menos 3 a 5 sub-secções com títulos claros e pertinentes ao tema. Para cada sub-secção, escreva um ou dois parágrafos iniciais desenvolvendo a ideia principal.
                6.  Conclusão: Apresente as principais descobertas ou reflexões finais sobre o tema.
                7.  Anexos (se aplicável): Indique que esta secção é para material complementar, se houver.
                8.  Referências Bibliográficas: Indique que esta secção listaria as fontes consultadas (deixe exemplos de como formatar referências, se possível, no estilo ABNT ou APA).
                
                Formate o texto de forma clara e organizada, usando títulos e subtítulos apropriados.`;

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.6, maxOutputTokens: 3000 }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao gerar relatório (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const reportContent = result.candidates[0].content.parts[0].text;
                    generatedReportContent.innerHTML = reportContent.replace(/\n/g, "<br>"); 
                    reportContentContainer.style.display = 'block';
                    btnExportReportPdf.style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter a estrutura do relatório da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        let radimakChatHistory = [];
        async function enviarMensagemChatRadimak() {
            const messageText = chatInput.value.trim();
            if (!messageText) return;

            appendMessageToChat("user", messageText);
            chatInput.value = ""; 

            if (!geminiFlashApiKey) {
                appendMessageToChat("radimak", "Desculpe, a API key para o Radimak não está configurada.");
                return;
            }
            loadingIndicator.textContent = "Radimak a pensar...";
            loadingIndicator.style.display = 'block';

            radimakChatHistory.push({ role: "user", parts: [{ text: messageText }] });

            try {
                const payload = {
                    contents: radimakChatHistory, 
                    generationConfig: { temperature: 0.7, maxOutputTokens: 1000 }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API Radimak (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const radimakResponse = result.candidates[0].content.parts[0].text;
                    appendMessageToChat("radimak", radimakResponse);
                    radimakChatHistory.push({ role: "model", parts: [{ text: radimakResponse }] });
                } else {
                    appendMessageToChat("radimak", "Desculpe, não consegui processar a sua mensagem neste momento.");
                }
            } catch (error) {
                appendMessageToChat("radimak", `Ocorreu um erro: ${error.message}`);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function appendMessageToChat(sender, message) {
            const messageDiv = document.createElement('div');
            messageDiv.style.marginBottom = '10px';
            messageDiv.style.padding = '8px';
            messageDiv.style.borderRadius = '6px';
            messageDiv.style.wordWrap = 'break-word';

            if (sender === "user") {
                messageDiv.style.backgroundColor = "var(--primary-red)";
                messageDiv.style.color = "var(--light-text)";
                messageDiv.style.textAlign = "right";
                messageDiv.style.marginLeft = "auto";
                messageDiv.style.maxWidth = "70%";
            } else { 
                messageDiv.style.backgroundColor = "#333";
                messageDiv.style.color = "var(--light-text)";
                messageDiv.style.textAlign = "left";
                messageDiv.style.marginRight = "auto";
                messageDiv.style.maxWidth = "70%";
            }
            messageDiv.textContent = message;
            chatMessagesContainer.appendChild(messageDiv);
            chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight; 
        }
        
        async function gerarIdeiasComIA() {
            const topic = ideaTopicInput.value.trim();
            if (!topic) {
                displayErrorMessage("Por favor, introduza um tópico para brainstorming.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A gerar ideias...";
            loadingIndicator.style.display = 'block';
            ideasDisplayContainer.style.display = 'none';
            btnExportIdeasPdf.style.display = 'none';

            const prompt = `Gere uma lista de ideias, diferentes perspetivas, ou um esboço de mapa mental sobre o seguinte tópico ou problema: "${topic}". Apresente as ideias de forma clara e concisa, talvez usando bullet points, uma estrutura numerada ou secções temáticas.`;
            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.7, maxOutputTokens: 1500 }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao gerar ideias (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const ideas = result.candidates[0].content.parts[0].text;
                    generatedIdeasText.textContent = ideas;
                    ideasDisplayContainer.style.display = 'block';
                    btnExportIdeasPdf.style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter ideias da resposta da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        async function gerarReceitaComIA() {
            const ingredients = recipeIngredients.value.trim();
            const cuisine = recipeCuisineType.value;
            const difficulty = recipeDifficulty.value;

            if (!ingredients) {
                displayErrorMessage("Por favor, liste os ingredientes que possui.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A gerar receita...";
            loadingIndicator.style.display = 'block';
            recipeDisplayContainer.style.display = 'none';
            btnExportRecipePdf.style.display = 'none';
            btnPlayRecipe.style.display = 'none';

            let prompt = `Crie uma receita detalhada utilizando principalmente os seguintes ingredientes: ${ingredients}.`;
            if (cuisine) {
                prompt += ` A receita deve ser do tipo de cozinha ${cuisine}.`;
            }
            if (difficulty) {
                prompt += ` O nível de dificuldade deve ser ${difficulty}.`;
            }
            prompt += ` A receita deve incluir:
                        1. Título da Receita.
                        2. Uma breve descrição (1-2 frases).
                        3. Tempo de Preparação estimado.
                        4. Tempo de Cozedura estimado.
                        5. Número de Porções.
                        6. Lista de Ingredientes completa (incluindo os fornecidos e quaisquer outros necessários, com quantidades).
                        7. Instruções passo a passo claras e detalhadas.
                        8. Opcional: Sugestões de acompanhamento ou dicas.
                        Formate a receita de forma clara e organizada.`;
            
            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.7, maxOutputTokens: 1500 }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao gerar receita (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const recipe = result.candidates[0].content.parts[0].text;
                    generatedRecipeText.textContent = recipe;
                    recipeDisplayContainer.style.display = 'block';
                    btnExportRecipePdf.style.display = 'inline-flex';
                    btnPlayRecipe.style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter a receita da resposta da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }


        function exportSlidesToPptx() {
            const slideContentRaw = generatedSlideContent.innerText; 
            if (!slideContentRaw || slideContentRaw.trim() === "") {
                displayErrorMessage("Não há conteúdo de slides para exportar.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A gerar ficheiro PPTX...";
            loadingIndicator.style.display = 'block';

            try {
                if (typeof PptxGenJS === 'undefined') {
                    throw new Error("Biblioteca PptxGenJS não carregada. Não é possível exportar para PPTX.");
                }
                if (typeof JSZip === 'undefined') { 
                    throw new Error("Biblioteca JSZip não carregada. É uma dependência para PptxGenJS.");
                }
                let pptx = new PptxGenJS();
                // pptx.layout = 'LAYOUT_16X9'; // Removido para usar o padrão da biblioteca

                const slideSections = slideContentRaw.split(/<h3>Slide \d+<\/h3>/i);
                
                let slideData = [];
                const sectionsToProcess = slideSections[0].trim() === "" ? slideSections.slice(1) : slideSections;

                sectionsToProcess.forEach(sectionText => {
                    const cleanedSection = sectionText.replace(/<hr>/gi, '').trim();
                    if (cleanedSection) {
                        const lines = cleanedSection.split('\n').map(line => line.trim()).filter(line => line);
                        if (lines.length > 0) {
                            let title = "Conteúdo do Slide"; 
                            let content = lines.join('\n');
                            const imageSuggestionMatch = content.match(/Sugestão de Imagem:\s*\[(.*?)\]/im);
                            const imageSuggestion = imageSuggestionMatch ? imageSuggestionMatch[1] : null;
                            if(imageSuggestion) {
                                content = content.replace(/Sugestão de Imagem:\s*\[.*?\]/im, '').trim();
                            }
                            const firstLineIsLikelyTitle = lines[0].length < 80 && !lines[0].includes('.') && !lines[0].toLowerCase().startsWith("sugestão de imagem:"); 
                            if(firstLineIsLikelyTitle && lines.length > 1){
                                title = lines[0];
                                content = lines.slice(1).join('\n').replace(/Sugestão de Imagem:\s*\[.*?\]/im, '').trim();
                            } else if (firstLineIsLikelyTitle && lines.length === 1 && !lines[0].toLowerCase().startsWith("sugestão de imagem:")) {
                                title = lines[0];
                                content = ""; 
                            }
                            slideData.push({ title, content, imageSuggestion });
                        }
                    }
                });


                if (slideData.length === 0 && slideContentRaw.trim() !== "") { 
                     let slide = pptx.addSlide();
                     slide.background = { color: "1f1f1f" };
                     slide.addText("Conteúdo dos Slides", { x: 0.5, y: 0.25, w: '90%', fontSize: 24, bold: true, color: "FFFFFF", align: 'center' });
                     slide.addText(slideContentRaw, { x: 0.5, y: 1.0, w: '90%', fontSize: 14, color: "E0E0E0" });
                } else if (slideData.length === 0) {
                     throw new Error("Não foi possível analisar o conteúdo dos slides para gerar o PPTX.");
                }


                slideData.forEach((data, index) => {
                    let slide = pptx.addSlide();
                    slide.background = { color: "1f1f1f" }; 
                    
                    slide.addText(data.title || `Slide ${index + 1}`, { 
                        x: 0.5, y: 0.25, w: '90%', h: 0.75, 
                        fontSize: 28, bold: true, color: "FFFFFF", align: 'center' 
                    });

                    if (data.content) {
                        slide.addText(data.content, { 
                            x: 0.5, y: 1.2, w: '90%', h: '75%', 
                            fontSize: 16, color: "E0E0E0", align: 'left',
                            lineSpacing: 24 
                        });
                    }

                    if (data.imageSuggestion) {
                        slide.addText(`Sugestão de Imagem: ${data.imageSuggestion}`, { 
                            x: 0.5, y: 5.0, w: '90%', h: 0.5, 
                            fontSize: 10, italic: true, color: "A0A0A0", align: 'left'
                        });
                    }
                });

                pptx.writeFile({ fileName: 'apresentacao_gerada.pptx' })
                    .then(() => console.log("Ficheiro PPTX gerado com sucesso."))
                    .catch(err => {
                        console.error("Erro ao gerar PPTX:", err);
                        displayErrorMessage("Erro ao gerar o ficheiro PPTX.");
                    });

            } catch (error) {
                console.error("Erro ao exportar para PPTX:", error);
                displayErrorMessage(`Erro ao exportar para PPTX: ${error.message}`);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        document.addEventListener('DOMContentLoaded', () => { 
            const btnExportPptx = document.getElementById('btnExportSlidePptx');
            if(btnExportPptx) {
                btnExportPptx.addEventListener('click', exportSlidesToPptx);
            }
        });


        function exportTextToPdf(text, filename = "documento.pdf") {
            if (!text || text.trim() === "") {
                displayErrorMessage("Não há conteúdo para exportar para PDF.");
                return;
            }
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                
                const margin = 15;
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const usableWidth = pageWidth - 2 * margin;
                let y = margin;
                doc.setFontSize(12);
                doc.setTextColor(0,0,0); 

                const lines = doc.splitTextToSize(text, usableWidth);

                lines.forEach(line => {
                    if (y + 10 > pageHeight - margin) { 
                        doc.addPage();
                        y = margin;
                    }
                    doc.text(line, margin, y);
                    y += 7; 
                });
                
                doc.save(filename);
            } catch (error) {
                console.error("Erro ao exportar para PDF:", error);
                displayErrorMessage("Ocorreu um erro ao tentar exportar o documento para PDF.");
            }
        }


        async function gerarImagemComIA() {
            const prompt = imagePromptTextarea.value.trim();
            if (!prompt) {
                displayErrorMessage("Por favor, descreva a imagem que deseja gerar.");
                return;
            }
            if (!imagenApiKey) {
                displayErrorMessage("A API key para o serviço de geração de imagem (Imagen) não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.style.display = 'block';
            loadingIndicator.textContent = "A gerar imagem com IA, aguarde...";
            aiGeneratedImageElement.style.display = 'none';
            aiImagePlaceholder.style.display = 'block';
            aiImagePlaceholder.textContent = "A sua imagem gerada por IA aparecerá aqui."; 
            aiImagePlaceholder.style.color = "#6c757d"; 
            btnDownloadAiImage.style.display = 'none';
            btnDeleteAiImage.style.display = 'none';

            try {
                const payload = { 
                    instances: [{ prompt: prompt }],
                    parameters: { "sampleCount": 1 } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${imagenApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Erro da API Imagen:", errorData);
                    let detailedErrorMessage = `Erro da API Imagen (${response.status}): ${response.statusText}.`;
                    if (errorData?.error?.message) {
                        detailedErrorMessage += ` Detalhes: ${errorData.error.message}`;
                        if (errorData.error.message.toLowerCase().includes("billed users") || errorData.error.message.toLowerCase().includes("billing")) {
                             detailedErrorMessage = "Erro: A API de geração de imagens (Imagen) requer uma conta Google Cloud com faturação ativa. Por favor, verifique as configurações da sua conta.";
                        } else if (errorData.error.message.toLowerCase().includes("api key not valid")) {
                            detailedErrorMessage = "Erro: A API key fornecida para a geração de imagens não é válida. Por favor, verifique a API key.";
                        }
                    }
                    throw new Error(detailedErrorMessage);
                }
                const result = await response.json();
                if (result.predictions?.[0]?.bytesBase64Encoded) {
                    const base64ImageData = result.predictions[0].bytesBase64Encoded;
                    aiGeneratedImageElement.src = `data:image/png;base64,${base64ImageData}`;
                    aiGeneratedImageElement.style.display = 'block';
                    aiImagePlaceholder.style.display = 'none';
                    btnDownloadAiImage.style.display = 'inline-flex';
                    btnDeleteAiImage.style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter a imagem da resposta da API. A resposta pode não conter os dados esperados.");
                }
            } catch (error) {
                displayErrorMessage(error.message); 
                aiImagePlaceholder.textContent = "Falha ao gerar imagem. Verifique a mensagem de erro acima.";
                aiImagePlaceholder.style.color = "red";
                aiImagePlaceholder.style.display = 'block';
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function baixarImagemGeradaIA() {
            if (!aiGeneratedImageElement.src || aiGeneratedImageElement.src.startsWith('#') || aiGeneratedImageElement.style.display === 'none') { 
                displayErrorMessage("Nenhuma imagem gerada por IA para baixar.");
                return;
            }
            clearErrorMessage();
            try {
                const link = document.createElement('a');
                link.download = 'imagem_gerada_ia.png';
                link.href = aiGeneratedImageElement.src;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (e) {
                displayErrorMessage("Ocorreu um erro ao tentar baixar a imagem da IA.");
            }
        }

        function apagarImagemGeradaIA() {
            aiGeneratedImageElement.src = '#'; 
            aiGeneratedImageElement.style.display = 'none';
            aiImagePlaceholder.textContent = "A sua imagem gerada por IA aparecerá aqui.";
            aiImagePlaceholder.style.color = "#6c757d";
            aiImagePlaceholder.style.display = 'block';
            btnDownloadAiImage.style.display = 'none';
            btnDeleteAiImage.style.display = 'none';
            clearErrorMessage();
        }

        function parseAudioMimeType(mimeTypeString) {
            const params = { rate: 24000, bitsPerSample: 16, channels: 1 }; 
            if (!mimeTypeString) return params;
            const parts = mimeTypeString.toLowerCase().split(';');
            parts.forEach(part => {
                const [key, value] = part.trim().split('=');
                if (key === 'rate' && !isNaN(parseInt(value))) {
                    params.rate = parseInt(value);
                } else if (key.startsWith('audio/l') && !isNaN(parseInt(key.substring(7)))) { 
                     params.bitsPerSample = parseInt(key.substring(7));
                } else if (key === 'channels' && !isNaN(parseInt(value))) {
                    params.channels = parseInt(value);
                }
            });
            if (parts[0].startsWith("audio/l")) {
                const bpsStr = parts[0].substring(7);
                if (!isNaN(parseInt(bpsStr))) {
                    params.bitsPerSample = parseInt(bpsStr);
                }
            }
            return params;
        }

        function convertPcmToWav(base64PcmData, originalMimeType) {
            console.log("A converter PCM para WAV. MimeType Original:", originalMimeType);
            const pcmData = Uint8Array.from(atob(base64PcmData), c => c.charCodeAt(0));
            const params = parseAudioMimeType(originalMimeType);
            const sampleRate = params.rate;
            const numChannels = params.channels; 
            const bitsPerSample = params.bitsPerSample;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = pcmData.length;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true); 
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); 
            view.setUint16(20, 1, true);  
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            new Uint8Array(buffer, 44).set(pcmData);
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        async function gerarFalaComIA(textToSpeak, sourceTitle = "Texto", isMultiSpeaker = false, voice1 = "Charon", voice2 = "Kore") { 
            if (!textToSpeak || textToSpeak.trim() === "") {
                displayErrorMessage("Não há texto para converter em fala.");
                audioPlayerContainer.style.display = 'none';
                return;
            }
            if (!ttsApiKey) {
                displayErrorMessage("A API key para o serviço de Text-to-Speech (TTS) não está configurada.");
                audioPlayerContainer.style.display = 'none';
                return;
            }
            clearErrorMessage();
            loadingIndicator.style.display = 'block';
            loadingIndicator.textContent = `A gerar fala para "${sourceTitle}", aguarde...`;
            audioPlayerContainer.style.display = 'none'; 

            try {
                const ttsModel = "gemini-2.5-pro-preview-tts"; 
                let speechConfigPayload = {};

                if (isMultiSpeaker) {
                    const speaker1Voice = document.getElementById('podcastSpeaker1Voice')?.value || voice1;
                    const speaker2Voice = document.getElementById('podcastSpeaker2Voice')?.value || voice2;
                    speechConfigPayload = { 
                        multiSpeakerVoiceConfig: {
                            speakerVoiceConfigs: [ 
                                { speaker: "Speaker 1", voiceConfig: { prebuiltVoiceConfig: { voice_name: speaker1Voice } } }, 
                                { speaker: "Speaker 2", voiceConfig: { prebuiltVoiceConfig: { voice_name: speaker2Voice } } }   
                            ]
                        }
                    };
                } else {
                     speechConfigPayload = { 
                        voiceConfig: { 
                            prebuiltVoiceConfig: { voice_name: voice1 } 
                        }
                    };
                }

                const payload = {
                    contents: [{ 
                        role: "user", 
                        parts: [{ text: textToSpeak }] 
                    }],
                    generationConfig: {
                        response_modalities: ["audio"],
                        temperature: 0.7, 
                        speechConfig: speechConfigPayload
                    }
                };
                
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${ttsModel}:generateContent?key=${ttsApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Erro da API TTS:", errorData);
                    let detailedErrorMessage = `Erro da API TTS (${response.status}): ${response.statusText || 'Erro desconhecido'}.`;
                    if (errorData?.error?.message) {
                        detailedErrorMessage += ` Detalhes: ${errorData.error.message}`;
                         if (response.status === 429 || errorData.error.message.toLowerCase().includes("quota") || errorData.error.message.toLowerCase().includes("resource_exhausted")) {
                            detailedErrorMessage = "Erro: Excedeu a sua quota atual para o serviço TTS. Por favor, verifique o seu plano e detalhes de faturação ou tente novamente mais tarde.";
                             if (errorData.details) { 
                                const helpLinkObj = errorData.details.find(d => d["@type"] === "type.googleapis.com/google.rpc.Help");
                                const helpLink = helpLinkObj?.links?.[0]?.url;
                                if (helpLink) {
                                    detailedErrorMessage += ` Consulte: ${helpLink}`;
                                }
                            }
                        } else if (response.status === 500 || errorData.error.message.toLowerCase().includes("internal error")) {
                            detailedErrorMessage = `Erro Interno do Servidor (500) ao contactar a API TTS. Por favor, tente novamente mais tarde. Se o problema persistir, reporte em https://developers.generativeai.google/guide/troubleshooting. (Detalhe API: ${errorData.error.message})`;
                        } else if (errorData.error.message.toLowerCase().includes("api key not valid")) {
                            detailedErrorMessage = "Erro: A API key fornecida para o serviço de TTS não é válida ou o modelo não está acessível com esta chave.";
                        } else if (errorData.error.message.toLowerCase().includes("billed users") || errorData.error.message.toLowerCase().includes("billing")) {
                             detailedErrorMessage = "Erro: A API de TTS pode requerer uma conta Google Cloud com faturação ativa.";
                        } else if (errorData.error.message.toLowerCase().includes("model not found") || errorData.error.message.toLowerCase().includes("is not supported") || errorData.error.message.toLowerCase().includes("voice name") ) {
                            detailedErrorMessage = `Erro: O modelo TTS ('${ttsModel}') ou a voz configurada não foram encontrados ou não são suportados. Verifique o nome do modelo, a voz e a documentação da API. (Detalhe API: ${errorData.error.message})`;
                        }
                    }
                    throw new Error(detailedErrorMessage);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0) {
                    const candidate = result.candidates[0];
                    if (candidate.finishReason !== "STOP") {
                         if (!candidate.content?.parts?.[0]?.inlineData?.data) {
                            let finishReasonMessage = `O modelo TTS não concluiu a geração com sucesso. Motivo: ${candidate.finishReason || 'Desconhecido'}. Não foi possível obter dados de áudio.`;
                            if (candidate.finishReason === "OTHER") { 
                                console.error("Resposta completa da API (finishReason OTHER, sem dados de áudio):", JSON.stringify(result, null, 2));
                                finishReasonMessage += " Isto pode indicar um problema com o texto de entrada (demasiado longo, caracteres inválidos), uma instabilidade temporária da API, ou o modelo pode não ter conseguido gerar áudio para este pedido específico. Tente com um texto mais simples ou mais curto, ou aguarde um pouco e tente novamente.";
                            }
                            throw new Error(finishReasonMessage);
                         }
                         console.warn(`O modelo TTS terminou com o motivo: ${candidate.finishReason || 'Desconhecido'}. A tentar usar os dados de áudio se disponíveis.`);
                    }

                    if (candidate.content?.parts?.[0]?.inlineData?.data) {
                        let audioDataB64 = candidate.content.parts[0].inlineData.data;
                        let finalMimeType = candidate.content.parts[0].inlineData.mimeType || 'audio/L16;rate=24000'; 
                        lastAttemptedMimeType = finalMimeType; 
                        console.log("Áudio recebido da API. MIME Type Original:", finalMimeType, "Tamanho (base64):", audioDataB64.length);
                        if (!audioDataB64.trim()) { 
                            throw new Error("Os dados de áudio recebidos da API estão vazios.");
                        }
                        if (finalMimeType.toLowerCase().includes("audio/l16") || 
                            finalMimeType.toLowerCase().includes("audio/l24") || 
                            finalMimeType.toLowerCase().includes("audio/l32") ||
                            finalMimeType.toLowerCase().includes("pcm")) {
                            try {
                                audioDataB64 = convertPcmToWav(audioDataB64, finalMimeType);
                                finalMimeType = 'audio/wav'; 
                                lastAttemptedMimeType = finalMimeType;
                                console.log("Áudio convertido para WAV. Novo MIME Type:", finalMimeType);
                            } catch (conversionError) {
                                console.error("Erro ao converter PCM para WAV:", conversionError);
                                throw new Error(`Falha ao converter áudio PCM para WAV: ${conversionError.message}`);
                            }
                        }
                        audioPlayer.src = `data:${finalMimeType};base64,${audioDataB64}`;
                        audioPlayer.onloadeddata = function() { 
                            console.log("Dados do áudio carregados (onloadeddata).");
                            audioPlayerContainer.style.display = 'block';
                            audioPlayer.play().catch(playError => { 
                                console.error("Erro ao tentar reproduzir o áudio:", playError);
                                displayErrorMessage("Erro ao iniciar a reprodução do áudio. Interação do utilizador pode ser necessária ou o formato de áudio pode não ser suportado.");
                            });
                        };
                        audioPlayer.load(); 
                        console.log("Fala gerada e src do áudio definido. A aguardar carregamento do áudio...");
                    } else {
                        console.error("Resposta da API TTS não contém dados de áudio válidos, mesmo com finishReason STOP (ou outro):", result);
                        throw new Error("Não foi possível obter os dados de áudio da resposta da API TTS. A estrutura da resposta pode estar incompleta.");
                    }
                } else {
                    console.error("Resposta inesperada da API TTS (sem candidatos):", result);
                    throw new Error("Resposta da API TTS não contém 'candidates'.");
                }
            } catch (error) {
                console.error("Erro ao gerar fala com IA:", error);
                displayErrorMessage(error.message);
                audioPlayerContainer.style.display = 'none';
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
    </script>

</body>
