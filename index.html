<!DOCTYPE html>
<html lang="pt-PT">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rad IA 2.0</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --primary-red: #e50914; 
            --dark-background: #141414; 
            --medium-dark-background: #1f1f1f; 
            --light-text: #ffffff;
            --medium-gray-text: #b3b3b3; 
            --dark-gray-text: #808080; 
            --accent-color-1: #f5a623; /* Laranja para imagens */
            --accent-color-2: #bd10e0; /* Roxo para TTS de texto */
            --accent-color-3: #7ed321; /* Verde para TTS de ficheiro */
            --accent-color-4: #6c757d; /* Cinza para Falar com IA */
            --accent-color-5: #e91e63; /* Rosa para Gerador de Guiões */
            --accent-color-6: #00bcd4; /* Ciano para Gerador de Atividades */
            --accent-color-7: #3f51b5; /* Indigo para Pesquisa */
            --accent-color-8: #009688; /* Teal para Tradutor */
            --border-color: #303030; 
            --shadow-color: rgba(0, 0, 0, 0.2); 
        }

        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 0; 
            background-color: var(--dark-background); 
            color: var(--light-text); 
            min-height: 100vh;
            box-sizing: border-box;
        }

        .top-bar {
            background-color: #000000; 
            color: var(--light-text);
            padding: 10px 20px; 
            width: 100%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-sizing: border-box;
            position: sticky; 
            top: 0;
            z-index: 1000; 
        }

        .top-bar .main-title {
            color: var(--primary-red); 
            margin: 0;
            font-size: 1.6em; 
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        nav ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap; 
            justify-content: center; 
            gap: 2px; 
        }

        nav ul li a {
            color: var(--medium-gray-text);
            text-decoration: none;
            padding: 8px 10px; 
            border-radius: 6px;
            transition: background-color 0.3s ease, color 0.3s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 5px; 
            font-size: 0.75em; 
        }

        nav ul li a:hover, nav ul li a.active {
            background-color: var(--primary-red);
            color: var(--light-text);
        }
        nav ul li a .fa-solid {
            transition: transform 0.2s ease-in-out;
            font-size: 0.9em; 
        }
        nav ul li a:hover .fa-solid {
            transform: scale(1.1);
        }


        .main-content-area {
            width: 100%;
            max-width: 960px; 
            padding: 20px; 
            box-sizing: border-box;
            margin-top: 60px; 
        }
        
        .generator-section {
            background-color: var(--medium-dark-background); 
            padding: 20px 25px; 
            border-radius: 10px; 
            box-shadow: 0 8px 20px var(--shadow-color); 
            margin-bottom: 30px; 
            text-align: left; 
            display: none; 
            border: 1px solid var(--border-color);
        }
        .generator-section.active {
            display: block;
        }

        .generator-section h2 {
            color: var(--light-text); 
            margin-top: 0;
            margin-bottom: 20px; 
            font-size: 1.6em; 
            border-bottom: 2px solid var(--primary-red); 
            padding-bottom: 12px; 
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px; 
        }
        .generator-section h2 .fa-solid { 
            font-size: 0.9em; 
            color: var(--primary-red); 
        }
        .generator-section h3 {
            color: var(--medium-gray-text);
            font-size: 1.1em;
            margin-top: 15px;
            margin-bottom: 8px;
        }


        #aiGeneratedImageContainer {
            margin-top: 15px;
            padding: 10px;
            border: 2px dashed var(--dark-gray-text); 
            border-radius: 8px;
            background-color: var(--dark-background); 
            min-height: 150px; 
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column; 
        }
        #aiGeneratedImage {
            max-width: 100%;
            max-height: 350px; 
            border-radius: 6px;
            object-fit: contain; 
        }
        #aiImagePlaceholder {
            color: var(--medium-gray-text);
            font-size: 0.9em;
        }

        .button-group {
            margin-top: 15px; 
            margin-bottom: 10px; 
            display: flex;
            flex-wrap: wrap;
            justify-content: flex-start; 
            gap: 10px; 
        }
        button { 
            padding: 10px 20px; 
            font-size: 0.9em; 
            font-weight: 600; 
            cursor: pointer;
            border: none;
            border-radius: 6px;
            transition: background-color 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
            color: var(--light-text); 
            letter-spacing: 0.5px;
            display: flex; 
            align-items: center;
            justify-content: center;
            gap: 8px;
            text-transform: uppercase; 
        }
        button:hover {
            transform: translateY(-2px); 
            box-shadow: 0 6px 12px rgba(0,0,0,0.2); 
        }

        /* Cores específicas dos botões */
        #btnRecordVoice { background-color: var(--accent-color-4); }
        #btnRecordVoice:hover { background-color: #5a5a5a; }
        #btnRecordVoice.recording { background-color: var(--primary-red); }
        #btnRecordVoice.recording:hover { background-color: #c50812; }

        #btnProcessFileToSpeech { background-color: var(--accent-color-3); }
        #btnProcessFileToSpeech:hover { background-color: #6ab01c; }

        #btnGenerateSpeechFromText { background-color: var(--accent-color-2); }
        #btnGenerateSpeechFromText:hover { background-color: #a30dbd; }
        
        #btnGenerateImageFromText { background-color: var(--accent-color-1); }
        #btnGenerateImageFromText:hover { background-color: #d88c1b; }

        #btnDownloadAiImage { background-color: var(--primary-red); } 
        #btnDownloadAiImage:hover { background-color: #c50812; }

        #btnDeleteAiImage { background-color: var(--dark-gray-text); } 
        #btnDeleteAiImage:hover { background-color: #666666; }
        
        #btnGenerateScript, #btnPlayScript { background-color: var(--accent-color-5); }
        #btnGenerateScript:hover, #btnPlayScript:hover { background-color: #c2185b; }

        #btnGenerateActivity { background-color: var(--accent-color-6); }
        #btnGenerateActivity:hover { background-color: #0097a7; }
        
        #btnSearchAI, #btnClearSearch { background-color: var(--accent-color-7); }
        #btnSearchAI:hover, #btnClearSearch:hover { background-color: #303f9f; }
        #btnClearSearch { background-color: var(--dark-gray-text); }
        #btnClearSearch:hover { background-color: #666; }

        #btnTranslateText, #btnPlayTranslatedText { background-color: var(--accent-color-8); }
        #btnTranslateText:hover, #btnPlayTranslatedText:hover { background-color: #00796b; }


        #errorMessage { 
            color: #f8d7da; 
            font-weight: 500; 
            margin: 20px auto; 
            padding: 12px 18px; 
            border-radius: 6px;
            background-color: #721c24; 
            border: 1px solid #f5c6cb; 
            text-align: left;
            display: none; 
            max-width: 900px; 
        }
        .loading-indicator {
            display: none;
            margin-top: 20px; 
            font-style: italic;
            color: var(--medium-gray-text); 
            font-size: 0.9em;
            text-align: center; 
        }
        textarea, select { 
            width: 100%; 
            padding: 10px; 
            margin-top: 8px;
            margin-bottom: 12px; 
            border-radius: 6px;
            border: 1px solid var(--dark-gray-text);
            font-family: 'Inter', sans-serif;
            font-size: 0.95em; 
            min-height: 40px; 
            box-sizing: border-box; 
            background-color: #2b2b2b; 
            color: var(--light-text); 
        }
        textarea {
            min-height: 70px;
            resize: vertical; 
        }
        textarea::placeholder {
            color: var(--medium-gray-text);
        }
        input[type="file"] {
            margin-top: 10px;
            margin-bottom: 15px;
            padding: 10px; 
            border: 1px solid var(--dark-gray-text);
            border-radius: 6px;
            font-family: 'Inter', sans-serif;
            font-size: 0.95em; 
            width: 100%;
            box-sizing: border-box;
            background-color: #2b2b2b; 
            color: var(--light-text);
        }
        input[type="file"]::file-selector-button { 
            background-color: var(--primary-red);
            color: var(--light-text);
            border: none;
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        input[type="file"]::file-selector-button:hover {
            background-color: #c50812;
        }
        
        #audioPlayerContainer, #voiceChatResponseContainer, #scriptDisplayContainer, #activityDisplayContainer, #searchResultsContainer, #translatedTextContainer {
            margin-top: 20px; 
            text-align: center; 
        }
        audio {
            width: 100%;
            max-width: 550px; 
            border-radius: 6px;
        }
        #voiceChatResponseText, #generatedScriptText, #generatedActivityText, #searchResultsText, #translatedTextOutput {
            background-color: #2b2b2b; 
            padding: 15px;
            border-radius: 6px;
            margin-top: 10px;
            text-align: left;
            white-space: pre-wrap; 
            font-size: 0.95em;
            color: var(--light-text); 
            border: 1px solid var(--border-color);
            max-height: 400px; 
            overflow-y: auto; 
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--medium-gray-text);
        }


        @media (max-width: 768px) {
            .top-bar {
                flex-direction: column;
                padding: 10px; 
                 position: static; 
            }
            .main-content-area {
                margin-top: 0; 
            }
            .top-bar .main-title {
                font-size: 1.5em; 
                margin-bottom: 10px;
            }
            nav ul {
                gap: 3px; 
            }
            nav ul li a {
                padding: 8px; 
                font-size: 0.7em; 
                gap: 4px;
            }
            nav ul li a .fa-solid {
                font-size: 0.8em; 
            }
            .main-content-area {
                padding: 15px 10px;
            }
            .generator-section h2 {
                font-size: 1.4em;
            }
            button { 
                width: 100%; 
                padding: 12px 15px; 
            }
            .button-group {
                flex-direction: column; 
                align-items: stretch; 
            }
            textarea, select, input[type="file"] {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <h1 class="main-title">Rad IA 2.0</h1>
        <nav>
            <ul>
                <li><a href="#" class="nav-link active" data-target="talkToAiSection"><i class="fa-solid fa-microphone-lines"></i> Falar</a></li>
                <li><a href="#" class="nav-link" data-target="fileToPodcastSection"><i class="fa-solid fa-file-audio"></i> Podcast</a></li>
                <li><a href="#" class="nav-link" data-target="textToSpeechSection"><i class="fa-solid fa-comment-dots"></i> Texto-Fala</a></li>
                <li><a href="#" class="nav-link" data-target="imageGeneratorSection"><i class="fa-solid fa-image"></i> Imagem</a></li>
                <li><a href="#" class="nav-link" data-target="scriptGeneratorSection"><i class="fa-solid fa-scroll"></i> Guião</a></li>
                <li><a href="#" class="nav-link" data-target="translatorSection"><i class="fa-solid fa-language"></i> Tradutor</a></li>
                <li><a href="#" class="nav-link" data-target="activityGeneratorSection"><i class="fa-solid fa-graduation-cap"></i> Atividades</a></li>
                <li><a href="#" class="nav-link" data-target="searchAiSection"><i class="fa-solid fa-search"></i> Pesquisa</a></li>
            </ul>
        </nav>
    </div>

    <div class="main-content-area">
        <p id="errorMessage"></p> 

        <div id="talkToAiSection" class="generator-section active">
            <h2><i class="fa-solid fa-headset"></i> Falar com a IA</h2>
            <div class="form-group">
                <label for="talkAiVoiceSelect">Escolha a Voz da IA:</label>
                <select id="talkAiVoiceSelect"></select>
            </div>
            <div class="button-group">
                <button id="btnRecordVoice"><i class="fa-solid fa-microphone"></i> Gravar Voz</button>
            </div>
            <div id="voiceChatResponseContainer" style="display:none;">
                <h3>Resposta da IA:</h3>
                <div id="voiceChatResponseText"></div>
            </div>
        </div>

        <div id="fileToPodcastSection" class="generator-section">
            <h2><i class="fa-solid fa-file-invoice"></i> Converter Ficheiro em Podcast (Diálogo)</h2>
            <input type="file" id="fileInput" accept="image/jpeg,image/png,image/gif,image/webp,application/pdf,.txt">
            <div class="form-group">
                <label for="podcastSpeaker1Voice">Voz do Apresentador 1:</label>
                <select id="podcastSpeaker1Voice"></select>
            </div>
            <div class="form-group">
                <label for="podcastSpeaker2Voice">Voz do Apresentador 2:</label>
                <select id="podcastSpeaker2Voice"></select>
            </div>
            <div class="button-group">
                <button id="btnProcessFileToSpeech"><i class="fa-solid fa-podcast"></i> Gerar Diálogo em Áudio</button>
                <button id="btnExportPdf" style="display:none;"><i class="fa-solid fa-file-pdf"></i> Exportar Guião para PDF</button>
            </div>
             <div id="podcastScriptDisplayContainer" style="display:none;">
                <h3>Guião do Podcast Gerado:</h3>
                <div id="generatedPodcastScriptText"></div>
            </div>
        </div>
        
        <div id="textToSpeechSection" class="generator-section">
            <h2><i class="fa-solid fa-align-left"></i> Gerador de Fala (Text-to-Speech)</h2>
            <textarea id="ttsInputText" placeholder="Escreva o texto que deseja converter em fala..."></textarea>
            <div class="form-group">
                <label for="ttsVoiceSelect">Escolha a Voz:</label>
                <select id="ttsVoiceSelect"></select>
            </div>
            <div class="button-group">
                <button id="btnGenerateSpeechFromText"><i class="fa-solid fa-volume-high"></i> Gerar Fala com IA (Texto)</button>
            </div>
        </div>
        
        <div id="audioPlayerContainer" style="display:none;"> 
            <audio id="audioPlayer" controls></audio>
        </div>

        <div id="imageGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-palette"></i> Criar Imagem com Inteligência Artificial</h2>
            <textarea id="imagePrompt" placeholder="Descreva a imagem que você quer gerar (ex: um gato astronauta a flutuar no espaço, pintura a óleo)"></textarea>
            <div class="button-group">
                <button id="btnGenerateImageFromText"><i class="fa-solid fa-wand-magic-sparkles"></i> Gerar Imagem com IA</button>
            </div>
            <div id="aiGeneratedImageContainer">
                <img id="aiGeneratedImage" src="#" alt="Imagem gerada por IA aparecerá aqui" style="display:none;"/>
                <span id="aiImagePlaceholder">A sua imagem gerada por IA aparecerá aqui.</span>
            </div>
            <div class="button-group">
                <button id="btnDownloadAiImage" style="display:none;"><i class="fa-solid fa-download"></i> Baixar Imagem da IA</button>
                <button id="btnDeleteAiImage" style="display:none;"><i class="fa-solid fa-trash-can"></i> Apagar Imagem da IA</button>
            </div>
        </div>

        <div id="scriptGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-feather-pointed"></i> Gerador de Guiões e Histórias</h2>
            <textarea id="scriptPrompt" placeholder="Descreva o tema, personagens, género ou ideia base para o seu guião ou história..."></textarea>
            <div class="form-group">
                <label for="scriptVoiceSelect">Voz para Narração:</label>
                <select id="scriptVoiceSelect"></select>
            </div>
            <div class="button-group">
                <button id="btnGenerateScript"><i class="fa-solid fa-book-open"></i> Gerar Guião/História</button>
            </div>
            <div id="scriptDisplayContainer" style="display:none;">
                <h3>Guião/História Gerada:</h3>
                <div id="generatedScriptText"></div>
                <div class="button-group">
                    <button id="btnPlayScript" style="display:none;"><i class="fa-solid fa-play-circle"></i> ✨ Ouvir Guião/História</button>
                </div>
            </div>
        </div>

        <div id="translatorSection" class="generator-section">
            <h2><i class="fa-solid fa-language"></i> Tradutor de Texto Inteligente</h2>
            <div class="form-group">
                <label for="sourceTextToTranslate">Texto para Traduzir:</label>
                <textarea id="sourceTextToTranslate" placeholder="Introduza o texto aqui..."></textarea>
            </div>
            <div class="form-group">
                <label for="sourceLanguageSelect">Língua de Origem:</label>
                <select id="sourceLanguageSelect">
                    <option value="auto">Detetar Automaticamente</option>
                    <option value="pt">Português</option>
                    <option value="en">Inglês</option>
                    <option value="es">Espanhol</option>
                    <option value="fr">Francês</option>
                    <option value="de">Alemão</option>
                    <option value="it">Italiano</option>
                    <option value="ja">Japonês</option>
                    <option value="ko">Coreano</option>
                    <option value="zh">Chinês (Simplificado)</option>
                </select>
            </div>
            <div class="form-group">
                <label for="targetLanguageSelect">Língua de Destino:</label>
                <select id="targetLanguageSelect">
                    <option value="pt">Português</option>
                    <option value="en" selected>Inglês</option>
                    <option value="es">Espanhol</option>
                    <option value="fr">Francês</option>
                    <option value="de">Alemão</option>
                    <option value="it">Italiano</option>
                    <option value="ja">Japonês</option>
                    <option value="ko">Coreano</option>
                    <option value="zh">Chinês (Simplificado)</option>
                </select>
            </div>
            <div class="form-group">
                <label for="translatorVoiceSelect">Voz para Tradução:</label>
                <select id="translatorVoiceSelect"></select>
            </div>
            <div class="button-group">
                <button id="btnTranslateText"><i class="fa-solid fa-exchange-alt"></i> Traduzir Texto</button>
            </div>
            <div id="translatedTextContainer" style="display:none;">
                <h3>Texto Traduzido:</h3>
                <div id="translatedTextOutput"></div>
                <div class="button-group">
                    <button id="btnPlayTranslatedText" style="display:none;"><i class="fa-solid fa-volume-up"></i> ✨ Ouvir Tradução</button>
                </div>
            </div>
        </div>


        <div id="activityGeneratorSection" class="generator-section">
            <h2><i class="fa-solid fa-graduation-cap"></i> Gerador de Atividades Escolares</h2>
            <div class="form-group">
                <label for="activityYearSelect">Ano Escolar:</label>
                <select id="activityYearSelect">
                    <option value="6">6º Ano - Ensino Fundamental</option>
                    <option value="7">7º Ano - Ensino Fundamental</option>
                    <option value="8">8º Ano - Ensino Fundamental</option>
                    <option value="9">9º Ano - Ensino Fundamental</option>
                </select>
            </div>
            <div class="form-group">
                <label for="activitySubjectSelect">Matéria:</label>
                <select id="activitySubjectSelect">
                    </select>
            </div>
            <div class="form-group">
                <label for="activitySpecificContentSelect">Conteúdo Específico:</label>
                 <select id="activitySpecificContentSelect">
                    </select>
            </div>
            <div class="form-group">
                <label for="activityNumQuestionsSelect">Número de Questões:</label>
                <select id="activityNumQuestionsSelect">
                    <option value="5">5 Questões</option>
                    <option value="10">10 Questões</option>
                    <option value="15">15 Questões</option>
                </select>
            </div>
            <div class="button-group">
                <button id="btnGenerateActivity"><i class="fa-solid fa-cogs"></i> Gerar Atividades</button>
            </div>
            <div id="activityDisplayContainer" style="display:none;">
                <h3>Atividades Geradas:</h3>
                <div id="generatedActivityText"></div>
                 <div class="button-group">
                    <button id="btnExportActivityPdf" style="display:none;"><i class="fa-solid fa-file-pdf"></i> Exportar Atividades para PDF</button>
                </div>
            </div>
        </div>

        <div id="searchAiSection" class="generator-section">
            <h2><i class="fa-solid fa-magnifying-glass"></i> Pesquisa com IA</h2>
            <textarea id="searchInput" placeholder="O que deseja pesquisar?"></textarea>
            <div class="button-group">
                <button id="btnSearchAI"><i class="fa-solid fa-paper-plane"></i> Pesquisar</button>
                <button id="btnClearSearch" style="display:none;"><i class="fa-solid fa-eraser"></i> Limpar Resultados</button>
            </div>
            <div id="searchResultsContainer" style="display:none;">
                <h3>Resultados da Pesquisa:</h3>
                <div id="searchResultsText"></div>
            </div>
        </div>
        
        <div class="loading-indicator" id="loadingIndicator">Aguarde, a contactar a API Gemini...</div>
    </div>

    <script>
        // API Keys
        const userProvidedApiKey = "AIzaSyDxcxVmGPBbg7mJ6_cmMDkHrDpbx3Lspik"; 
        const geminiFlashApiKey = userProvidedApiKey; 
        const imagenApiKey = userProvidedApiKey; 
        const ttsApiKey = userProvidedApiKey; 

        const availableVoices = [
            { name: "Zephyr", value: "Zephyr" }, { name: "Puck", value: "Puck" },
            { name: "Charon", value: "Charon" }, { name: "Kore", value: "Kore" },
            { name: "Alnilam", value: "Alnilam" }, { name: "Sadachbia", value: "Sadachbia" },
            { name: "Leda", value: "Leda" } 
        ];
        
        const conteudosPorMateriaAno = {
            "Matemática": {
                "6": ["Números Naturais e Operações Fundamentais", "Múltiplos e Divisores (MMC e MDC)", "Frações: Conceitos e Operações", "Números Decimais e Operações", "Porcentagem Básica", "Geometria: Figuras Planas e Sólidos Geométricos", "Medidas de Comprimento, Massa, Capacidade e Tempo"],
                "7": ["Números Inteiros: Operações e Ordenação", "Números Racionais: Frações e Decimais (positivos e negativos)", "Equações de 1º Grau com uma Incógnita", "Razão e Proporção", "Regra de Três Simples", "Porcentagem e Juros Simples", "Ângulos e suas Classificações", "Polígonos: Classificação e Propriedades", "Área de Figuras Planas (quadrado, retângulo, triângulo)"],
                "8": ["Números Reais e Potenciação com Expoente Inteiro", "Radiciação", "Produtos Notáveis e Fatoração Algébrica", "Sistemas de Equações de 1º Grau com Duas Incógnitas", "Equações de 2º Grau (introdução, fórmula de Bhaskara)", "Teorema de Pitágoras", "Semelhança de Triângulos", "Volume de Prismas e Cilindros", "Estatística: Leitura e Interpretação de Gráficos e Tabelas"],
                "9": ["Potenciação e Radiciação (revisão e aprofundamento)", "Função Afim (1º Grau): Gráfico e Propriedades", "Função Quadrática (2º Grau): Gráfico e Vértice", "Equações de 2º Grau Completas e Incompletas", "Relações Métricas no Triângulo Retângulo (além de Pitágoras)", "Trigonometria no Triângulo Retângulo (seno, cosseno, tangente)", "Semelhança de Figuras Geométricas", "Juros Compostos", "Noções de Probabilidade"]
            },
            "Português": {
                "6": ["Interpretação de Textos Diversos (narrativos, descritivos, informativos)", "Gêneros Textuais: Conto, Fábula, Notícia", "Substantivos (classificação, flexão)", "Adjetivos e Locuções Adjetivas", "Artigos Definidos e Indefinidos", "Pronomes Pessoais", "Verbos: Tempos do Modo Indicativo (presente, pretérito perfeito, futuro do presente)", "Ortografia: Uso de S/Z, X/CH, G/J", "Pontuação Básica"],
                "7": ["Interpretação de Textos Argumentativos Simples", "Gêneros Textuais: Crônica, Reportagem, Poema", "Pronomes Possessivos, Demonstrativos e Indefinidos", "Advérbios e Locuções Adverbiais", "Preposições e Conjunções Coordenativas", "Verbos: Tempos do Modo Subjuntivo (presente, pretérito imperfeito)", "Concordância Nominal Básica", "Figuras de Linguagem (metáfora, comparação)", "Coesão e Coerência Textual"],
                "8": ["Interpretação de Textos Literários e Não Literários (análise crítica)", "Gêneros Textuais: Artigo de Opinião, Resenha, Texto Teatral", "Vozes Verbais (ativa, passiva, reflexiva)", "Conjunções Subordinativas", "Período Composto por Coordenação e Subordinação (orações adjetivas e adverbiais)", "Concordância Verbal Básica", "Regência Nominal e Verbal (casos simples)", "Colocação Pronominal (próclise, mesóclise, ênclise)"],
                "9": ["Análise de Discurso em Diferentes Textos", "Gêneros Textuais: Editorial, Manifesto, Seminário", "Funções da Linguagem", "Variação Linguística (regional, social, histórica)", "Sintaxe do Período Composto (aprofundamento)", "Pontuação Expressiva e Estilística", "Intertextualidade", "Literatura Brasileira (introdução a movimentos literários)"]
            },
            "Ciências": {
                "6": ["O Universo e o Sistema Solar", "A Terra: Movimentos e Camadas", "Água no Planeta Terra (ciclo, estados físicos, importância)", "Solo: Formação e Tipos", "Ar Atmosférico: Composição e Importância", "Seres Vivos: Características e Classificação Básica (Reinos)", "Cadeias e Teias Alimentares"],
                "7": ["Máquinas Simples e Transformações de Energia", "Fontes de Energia (renováveis e não renováveis)", "Calor e Temperatura: Propagação e Efeitos", "Som e Luz: Propriedades Básicas", "Ecossistemas Brasileiros", "Relações Ecológicas", "Impactos Ambientais (desmatamento, poluição)"],
                "8": ["Corpo Humano: Organização Celular e Níveis de Organização", "Sistemas do Corpo Humano: Digestório, Respiratório, Circulatório e Excretor", "Sistema Nervoso e Sentidos", "Sistema Locomotor (ossos e músculos)", "Reprodução Humana e Sexualidade", "Saúde e Doenças (prevenção, vacinação)"],
                "9": ["Genética: Hereditariedade e Leis de Mendel (introdução)", "Evolução das Espécies (ideias de Darwin e Lamarck)", "Química: Matéria, Átomos e Moléculas", "Tabela Periódica (elementos principais)", "Misturas e Separação de Misturas", "Reações Químicas (conceito básico)", "Física: Movimento, Força e Leis de Newton (introdução)"]
            },
             "História": {
                "6": ["O que é História? Fontes Históricas", "Pré-História: Paleolítico e Neolítico", "Antiguidade Oriental: Mesopotâmia e Egito", "Antiguidade Clássica: Grécia (Atenas e Esparta, Democracia, Cultura)", "Antiguidade Clássica: Roma (República e Império, Legado Cultural)"],
                "7": ["A Formação da Europa Feudal", "Império Bizantino e o Mundo Islâmico Medieval", "As Cruzadas", "Renascimento Comercial e Urbano", "Grandes Navegações e a Descoberta da América", "Povos Indígenas da América antes da Conquista"],
                "8": ["Iluminismo e a Revolução Francesa", "Revolução Industrial", "Independência dos Estados Unidos", "Período Napoleônico e o Congresso de Viena", "Independência das Colônias da América Espanhola", "Brasil Imperial: Primeiro Reinado e Período Regencial"],
                "9": ["Brasil Imperial: Segundo Reinado e Crise da Monarquia", "Proclamação da República no Brasil e a República Velha", "Primeira Guerra Mundial", "Revolução Russa", "Crise de 1929 e o Período Entreguerras", "Segunda Guerra Mundial", "Guerra Fria e a Nova Ordem Mundial"]
            },
            "Geografia": {
                "6": ["O Espaço Geográfico e a Paisagem", "Orientação e Localização no Espaço (pontos cardeais, coordenadas)", "Representações Cartográficas (mapas, escalas)", "O Planeta Terra: Movimentos e Zonas Climáticas", "Relevo, Hidrografia e Vegetação do Brasil (introdução)", "População Brasileira: Formação e Distribuição"],
                "7": ["Formação Territorial do Brasil", "Regiões Brasileiras: Aspectos Físicos, Econômicos e Sociais", "Urbanização Brasileira e Problemas Urbanos", "Atividades Econômicas no Brasil: Agropecuária, Indústria e Serviços", "Fontes de Energia e Recursos Minerais no Brasil"],
                "8": ["Globalização e Blocos Econômicos Mundiais", "Continentes: Aspectos Físicos e Humanos (foco em América e África)", "Conflitos Mundiais Contemporâneos e Geopolítica", "Desenvolvimento e Subdesenvolvimento", "Questões Ambientais Globais (aquecimento global, desertificação)"],
                "9": ["Europa: Aspectos Físicos, Econômicos e União Europeia", "Ásia: Potências Regionais e Diversidade Cultural (China, Índia, Japão)", "Oceania e Regiões Polares", "Redes Geográficas e Fluxos Mundiais (comércio, informação)", "Brasil no Contexto Global: Relações Internacionais e Desafios"]
            }
        };


        // Elementos do DOM
        // ... (outros elementos já definidos) ...
        let activitySpecificContentSelect;


        window.onload = function() {
            // ... (inicialização de outros elementos) ...
            errorMessageElement = document.getElementById('errorMessage'); 
            loadingIndicator = document.getElementById('loadingIndicator');
            
            btnRecordVoice = document.getElementById('btnRecordVoice');
            voiceChatResponseContainer = document.getElementById('voiceChatResponseContainer');
            voiceChatResponseText = document.getElementById('voiceChatResponseText');
            talkAiVoiceSelect = document.getElementById('talkAiVoiceSelect');

            fileInput = document.getElementById('fileInput');
            btnProcessFileToSpeech = document.getElementById('btnProcessFileToSpeech');
            btnExportPdf = document.getElementById('btnExportPdf');
            podcastScriptDisplayContainer = document.getElementById('podcastScriptDisplayContainer');
            generatedPodcastScriptText = document.getElementById('generatedPodcastScriptText');
            
            ttsInputText = document.getElementById('ttsInputText');
            btnGenerateSpeechFromText = document.getElementById('btnGenerateSpeechFromText'); 
            audioPlayer = document.getElementById('audioPlayer');
            audioPlayerContainer = document.getElementById('audioPlayerContainer');
            
            imagePromptTextarea = document.getElementById('imagePrompt');
            btnGenerateImageFromText = document.getElementById('btnGenerateImageFromText');
            aiGeneratedImageElement = document.getElementById('aiGeneratedImage');
            aiImagePlaceholder = document.getElementById('aiImagePlaceholder');
            aiGeneratedImageContainer = document.getElementById('aiGeneratedImageContainer');
            btnDownloadAiImage = document.getElementById('btnDownloadAiImage');
            btnDeleteAiImage = document.getElementById('btnDeleteAiImage');

            scriptPromptTextarea = document.getElementById('scriptPrompt');
            btnGenerateScript = document.getElementById('btnGenerateScript');
            scriptDisplayContainer = document.getElementById('scriptDisplayContainer');
            generatedScriptText = document.getElementById('generatedScriptText');
            btnPlayScript = document.getElementById('btnPlayScript');
            scriptVoiceSelect = document.getElementById('scriptVoiceSelect');

            activityYearSelect = document.getElementById('activityYearSelect');
            activitySubjectSelect = document.getElementById('activitySubjectSelect');
            activitySpecificContentSelect = document.getElementById('activitySpecificContentSelect'); // Novo seletor
            activityNumQuestionsSelect = document.getElementById('activityNumQuestionsSelect');
            btnGenerateActivity = document.getElementById('btnGenerateActivity');
            activityDisplayContainer = document.getElementById('activityDisplayContainer');
            generatedActivityText = document.getElementById('generatedActivityText');
            btnExportActivityPdf = document.getElementById('btnExportActivityPdf');

            searchInput = document.getElementById('searchInput');
            btnSearchAI = document.getElementById('btnSearchAI');
            searchResultsContainer = document.getElementById('searchResultsContainer');
            searchResultsText = document.getElementById('searchResultsText');
            btnClearSearch = document.getElementById('btnClearSearch');

            sourceTextToTranslate = document.getElementById('sourceTextToTranslate');
            sourceLanguageSelect = document.getElementById('sourceLanguageSelect');
            targetLanguageSelect = document.getElementById('targetLanguageSelect');
            btnTranslateText = document.getElementById('btnTranslateText');
            translatedTextContainer = document.getElementById('translatedTextContainer');
            translatedTextOutput = document.getElementById('translatedTextOutput');
            btnPlayTranslatedText = document.getElementById('btnPlayTranslatedText');
            translatorVoiceSelect = document.getElementById('translatorVoiceSelect');


            populateVoiceSelectors();
            populateActivitySubjects(); // Popula matérias inicialmente
            updateSpecificContentOptions(); // Popula conteúdos com base na seleção inicial
            
            navLinks = document.querySelectorAll('nav .nav-link');
            generatorSections = document.querySelectorAll('.generator-section');

            navLinks.forEach(link => {
                link.addEventListener('click', function(event) {
                    event.preventDefault();
                    const targetId = this.getAttribute('data-target');
                    navLinks.forEach(navLink => navLink.classList.remove('active'));
                    this.classList.add('active');
                    generatorSections.forEach(section => {
                        section.style.display = section.id === targetId ? 'block' : 'none';
                    });
                    clearErrorMessage(); 
                    audioPlayerContainer.style.display = 'none'; 
                });
            });
            if (navLinks.length > 0) document.querySelector('.nav-link[data-target="talkToAiSection"]').click();

            // Event Listeners
            btnGenerateImageFromText.addEventListener('click', gerarImagemComIA);
            btnDownloadAiImage.addEventListener('click', baixarImagemGeradaIA);
            btnDeleteAiImage.addEventListener('click', apagarImagemGeradaIA);
            btnGenerateSpeechFromText.addEventListener('click', () => { 
                 const textToSpeak = ttsInputText.value.trim();
                 const selectedVoice = document.getElementById('ttsVoiceSelect').value;
                 if (textToSpeak) {
                    gerarFalaComIA(textToSpeak, "Texto Introduzido", false, selectedVoice); 
                 } else {
                    displayErrorMessage("Por favor, introduza o texto que deseja converter em fala.");
                 }
            });
            btnProcessFileToSpeech.addEventListener('click', processFileToSpeech);
            btnRecordVoice.addEventListener('click', toggleVoiceRecording);
            btnGenerateScript.addEventListener('click', gerarGuiaoHistoria);
            btnPlayScript.addEventListener('click', () => {
                const scriptContent = generatedScriptText.textContent;
                const selectedVoice = scriptVoiceSelect.value;
                if (scriptContent) {
                    gerarFalaComIA(scriptContent, "Guião/História Gerada", false, selectedVoice); 
                }
            });
            btnGenerateActivity.addEventListener('click', gerarAtividadesComIA);
            activityYearSelect.addEventListener('change', updateSpecificContentOptions);
            activitySubjectSelect.addEventListener('change', updateSpecificContentOptions);

            btnSearchAI.addEventListener('click', pesquisarComIA);
            btnClearSearch.addEventListener('click', () => {
                searchResultsText.textContent = '';
                searchResultsContainer.style.display = 'none';
                btnClearSearch.style.display = 'none';
            });
             btnExportPdf.addEventListener('click', () => exportTextToPdf(generatedPodcastScriptText.textContent, "guiao_podcast.pdf"));
             btnExportActivityPdf.addEventListener('click', () => exportTextToPdf(generatedActivityText.textContent, "atividades_geradas.pdf"));
             btnTranslateText.addEventListener('click', translateTextWithAI);
             btnPlayTranslatedText.addEventListener('click', () => {
                const translatedContent = translatedTextOutput.textContent;
                const selectedVoice = translatorVoiceSelect.value;
                if (translatedContent) {
                    gerarFalaComIA(translatedContent, "Texto Traduzido", false, selectedVoice);
                }
             });


            audioPlayer.onerror = function(e) {
                console.error("Erro no elemento de áudio:", e);
                let specificError = "Erro desconhecido ao carregar o áudio.";
                if (audioPlayer.error) {
                    switch (audioPlayer.error.code) {
                        case MediaError.MEDIA_ERR_ABORTED: specificError = "A reprodução do áudio foi abortada."; break;
                        case MediaError.MEDIA_ERR_NETWORK: specificError = "Ocorreu um erro de rede ao carregar o áudio."; break;
                        case MediaError.MEDIA_ERR_DECODE: specificError = "Ocorreu um erro ao descodificar o áudio. O formato pode ser inválido ou não suportado."; break;
                        case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED: specificError = "O formato do áudio não é suportado ou a fonte não pôde ser encontrada."; break;
                        default: specificError = `Ocorreu um erro ao carregar o áudio (código: ${audioPlayer.error.code}).`;
                    }
                }
                displayErrorMessage(specificError + ` (Tipo MIME tentado: ${lastAttemptedMimeType})`);
                audioPlayerContainer.style.display = 'none';
            };
        };

        function populateVoiceSelectors() {
            const selectors = [
                { id: 'talkAiVoiceSelect', default: 'Charon' },
                { id: 'podcastSpeaker1Voice', default: 'Charon' },
                { id: 'podcastSpeaker2Voice', default: 'Kore' },
                { id: 'ttsVoiceSelect', default: 'Zephyr' },
                { id: 'scriptVoiceSelect', default: 'Zephyr' },
                { id: 'translatorVoiceSelect', default: 'Zephyr'} 
            ];

            selectors.forEach(selInfo => {
                const selectElement = document.getElementById(selInfo.id);
                if (selectElement) {
                    availableVoices.forEach(voice => {
                        const option = document.createElement('option');
                        option.value = voice.value;
                        option.textContent = voice.name;
                        if (voice.value === selInfo.default) {
                            option.selected = true;
                        }
                        selectElement.appendChild(option);
                    });
                }
            });
        }
        
        function populateActivitySubjects() {
            const subjects = Object.keys(conteudosPorMateriaAno);
            activitySubjectSelect.innerHTML = ''; // Limpa opções existentes
            subjects.forEach(subject => {
                const option = document.createElement('option');
                option.value = subject;
                option.textContent = subject;
                activitySubjectSelect.appendChild(option);
            });
        }

        function updateSpecificContentOptions() {
            const selectedYear = activityYearSelect.value;
            const selectedSubject = activitySubjectSelect.value;
            activitySpecificContentSelect.innerHTML = ''; // Limpa opções existentes

            if (conteudosPorMateriaAno[selectedSubject] && conteudosPorMateriaAno[selectedSubject][selectedYear]) {
                const contents = conteudosPorMateriaAno[selectedSubject][selectedYear];
                contents.forEach(content => {
                    const option = document.createElement('option');
                    option.value = content;
                    option.textContent = content;
                    activitySpecificContentSelect.appendChild(option);
                });
            } else {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "Nenhum conteúdo específico disponível";
                option.disabled = true;
                activitySpecificContentSelect.appendChild(option);
            }
        }


        function displayErrorMessage(message) {
            errorMessageElement.textContent = message;
            errorMessageElement.style.display = 'block';
            errorMessageElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }

        function clearErrorMessage() {
            errorMessageElement.textContent = '';
            errorMessageElement.style.display = 'none';
        }

        function readFileAsBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(new Error(`Erro ao ler o ficheiro: ${error.message}`));
                reader.readAsDataURL(file);
            });
        }
        
        function readFileAsText(file) {
             return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = error => reject(new Error(`Erro ao ler o ficheiro de texto: ${error.message}`));
                reader.readAsText(file);
            });
        }

        async function toggleVoiceRecording() {
            if (mediaRecorder && mediaRecorder.state === "recording") {
                mediaRecorder.stop();
            } else {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' }); 
                    audioChunks = []; 
                    mediaRecorder.ondataavailable = event => audioChunks.push(event.data);
                    mediaRecorder.onstart = () => { 
                        btnRecordVoice.innerHTML = '<i class="fa-solid fa-stop"></i> Parar Gravação';
                        btnRecordVoice.classList.add("recording");
                        loadingIndicator.style.display = 'none'; 
                        clearErrorMessage();
                        voiceChatResponseContainer.style.display = 'none';
                        audioPlayerContainer.style.display = 'none'; 
                    };
                    mediaRecorder.onstop = async () => {
                        btnRecordVoice.innerHTML = '<i class="fa-solid fa-microphone"></i> Gravar Voz';
                        btnRecordVoice.classList.remove("recording");
                        loadingIndicator.textContent = "A processar áudio gravado...";
                        loadingIndicator.style.display = 'block';
                        const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType });
                        audioChunks = []; 
                        stream.getTracks().forEach(track => track.stop()); 
                        try {
                            const base64Audio = await readFileAsBase64(audioBlob);
                            await sendAudioToGemini(base64Audio, mediaRecorder.mimeType);
                        } catch (error) {
                            displayErrorMessage(`Erro ao processar áudio gravado: ${error.message}`);
                        } finally {
                            loadingIndicator.style.display = 'none';
                        }
                    };
                    mediaRecorder.start();
                } catch (error) {
                    displayErrorMessage("Não foi possível aceder ao microfone. Verifique as permissões.");
                    btnRecordVoice.innerHTML = '<i class="fa-solid fa-microphone"></i> Gravar Voz';
                    btnRecordVoice.classList.remove("recording");
                }
            }
        }

        async function sendAudioToGemini(base64AudioData, mimeType) {
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            loadingIndicator.textContent = "A IA está a pensar...";
            loadingIndicator.style.display = 'block';
            const payload = { contents: [{ role: "user", parts: [ { inlineData: { mimeType: mimeType, data: base64AudioData } } ] }] };
            try {
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao processar áudio (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const aiResponseText = result.candidates[0].content.parts[0].text;
                    voiceChatResponseText.textContent = aiResponseText;
                    voiceChatResponseContainer.style.display = 'block';
                    const selectedVoice = talkAiVoiceSelect.value;
                    await gerarFalaComIA(aiResponseText, "Resposta da IA", false, selectedVoice); 
                } else {
                    throw new Error("Não foi possível obter uma resposta de texto da IA para o áudio enviado.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        async function getSummaryForTTS(base64Data, mimeType, fileType) {
            if (!geminiFlashApiKey) throw new Error("API key para Gemini Flash não configurada.");
            
            let promptText = "";
            let maxTokens = 2000; 
            if (fileType === "image") {
                promptText = "Crie um resumo detalhado desta imagem, com informação suficiente para gerar um diálogo de podcast com cerca de 2-3 minutos de duração. Destaque os elementos visuais principais, a atmosfera geral e em quaisquer textos visíveis. Seja descritivo e envolvente.";
                maxTokens = 700; 
            } else if (fileType === "pdf") {
                promptText = "Crie um resumo detalhado e abrangente deste documento PDF, com informação suficiente para gerar um diálogo de podcast com aproximadamente 7 minutos de duração. Foque-se nas ideias principais, argumentos, exemplos e conclusões, omitindo apenas detalhes menores ou informação redundante. O objetivo é ter material rico para uma discussão entre duas vozes.";
                maxTokens = 3500; 
            } else if (fileType === "text") {
                 promptText = "Crie um resumo detalhado e abrangente deste texto, com informação suficiente para gerar um diálogo de podcast com aproximadamente 7 minutos de duração. Foque-se nas ideias principais, argumentos, exemplos e conclusões. O objetivo é ter material rico para uma discussão entre duas vozes.";
                 maxTokens = 3500; 
            }

            const payload = {
                contents: [{ role: "user", parts: [{ text: promptText }, { inlineData: { mimeType: mimeType, data: base64Data } }] }],
                generationConfig: { maxOutputTokens: maxTokens, temperature: 0.6 } 
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
            loadingIndicator.textContent = `A gerar resumo de ${fileType}...`;
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Erro ao obter resumo de ${fileType} (${response.status}): ${errorData?.error?.message || response.statusText}`);
            }
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                return result.candidates[0].content.parts[0].text;
            }
            throw new Error(`Não foi possível extrair o resumo de ${fileType} da API.`);
        }

        async function generateDialogueFromSummary(summaryText) {
            if (!geminiFlashApiKey) throw new Error("API key para Gemini Flash (geração de diálogo) não configurada.");
            loadingIndicator.textContent = "A criar guião de diálogo para o podcast...";
            
            const prompt = `Com base no seguinte resumo detalhado, crie um guião de diálogo extenso e envolvente (visando aproximadamente 1000-1500 palavras, o que pode equivaler a cerca de 7-10 minutos de fala) entre duas pessoas (identificadas como "Speaker 1:" e "Speaker 2:") para um podcast. O diálogo deve explorar os pontos principais do resumo de forma natural, aprofundada e conversacional, como se fosse uma discussão real. Formate o guião claramente com "Speaker 1:" e "Speaker 2:" antes de cada fala. Não adicione nenhuma introdução ou conclusão ao diálogo, apenas as falas dos speakers. Resumo:\n\n${summaryText}`;
            
            const payload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                generationConfig: { maxOutputTokens: 2500, temperature: 0.75 } 
            };
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Erro ao gerar diálogo (${response.status}): ${errorData?.error?.message || response.statusText}`);
            }
            const result = await response.json();
            if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                generatedPodcastScriptText.textContent = result.candidates[0].content.parts[0].text; 
                podcastScriptDisplayContainer.style.display = 'block';
                btnExportPdf.style.display = 'inline-flex';
                return result.candidates[0].content.parts[0].text;
            }
            throw new Error("Não foi possível gerar o guião do diálogo a partir do resumo.");
        }


        async function processFileToSpeech() {
            const file = fileInput.files[0];
            if (!file) {
                displayErrorMessage("Por favor, selecione um ficheiro.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.style.display = 'block';
            audioPlayerContainer.style.display = 'none';
            podcastScriptDisplayContainer.style.display = 'none';
            btnExportPdf.style.display = 'none';


            try {
                let summaryText = "";
                let fileDescriptionForTTS = file.name;
                let fileTypeForSummary = "";

                if (file.type.startsWith("image/")) {
                    fileTypeForSummary = "image";
                    const base64FileContent = await readFileAsBase64(file);
                    summaryText = await getSummaryForTTS(base64FileContent, file.type, fileTypeForSummary);
                    fileDescriptionForTTS = `Podcast sobre a imagem ${file.name}`;
                } else if (file.type === "application/pdf") {
                     fileTypeForSummary = "pdf";
                    const base64FileContent = await readFileAsBase64(file);
                    summaryText = await getSummaryForTTS(base64FileContent, "application/pdf", fileTypeForSummary);
                    fileDescriptionForTTS = `Podcast sobre o PDF ${file.name}`;
                } else if (file.type === "text/plain") {
                    fileTypeForSummary = "text"; 
                    const rawText = await readFileAsText(file); 
                    summaryText = await getSummaryForTTS(rawText, "text/plain", fileTypeForSummary); 
                    fileDescriptionForTTS = `Podcast sobre o ficheiro ${file.name}`;
                } else {
                    throw new Error(`Tipo de ficheiro não suportado: ${file.type}. Por favor, selecione uma imagem, PDF ou ficheiro .txt.`);
                }

                if (summaryText) {
                    const dialogueScript = await generateDialogueFromSummary(summaryText);
                    if (dialogueScript) {
                        await gerarFalaComIA(dialogueScript, fileDescriptionForTTS, true); 
                    } else {
                        throw new Error("Falha ao gerar o guião do diálogo.");
                    }
                } else {
                    throw new Error("Não foi possível extrair ou resumir conteúdo do ficheiro para conversão em fala.");
                }

            } catch (error) {
                console.error("Erro ao processar ficheiro para fala:", error);
                displayErrorMessage(`Erro ao processar ficheiro: ${error.message}`);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        async function gerarGuiaoHistoria() {
            const prompt = scriptPromptTextarea.value.trim();
            if (!prompt) {
                displayErrorMessage("Por favor, forneça um tema ou ideia para o guião/história.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A gerar guião/história...";
            loadingIndicator.style.display = 'block';
            scriptDisplayContainer.style.display = 'none';
            btnPlayScript.style.display = 'none';

            const generationPrompt = `Crie um guião curto ou uma história (aproximadamente 300-500 palavras) com base no seguinte: "${prompt}". Se for um guião, defina claramente os personagens e as suas falas (ex: PERSONAGEM: Fala.). Se for uma história, escreva uma narrativa envolvente.`;

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: generationPrompt }] }],
                    generationConfig: { temperature: 0.8, maxOutputTokens: 800 }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao gerar guião (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const script = result.candidates[0].content.parts[0].text;
                    generatedScriptText.textContent = script;
                    scriptDisplayContainer.style.display = 'block';
                    btnPlayScript.style.display = 'inline-flex'; 
                } else {
                    throw new Error("Não foi possível obter o guião/história da resposta da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        async function gerarAtividadesComIA() {
            const ano = activityYearSelect.value;
            const materia = activitySubjectSelect.value;
            const conteudo = activitySpecificContentSelect.value; // Usar o valor do novo seletor
            const numQuestoes = activityNumQuestionsSelect.value;

            if (!conteudo) { // Verifica se um conteúdo foi selecionado
                displayErrorMessage("Por favor, selecione o conteúdo específico para as atividades.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A gerar atividades...";
            loadingIndicator.style.display = 'block';
            activityDisplayContainer.style.display = 'none';
            btnExportActivityPdf.style.display = 'none';

            const prompt = `Crie ${numQuestoes} questões de ${materia} para alunos do ${ano}º ano do Ensino Fundamental, focadas no seguinte conteúdo: "${conteudo}". As questões devem ser claras, adequadas ao nível de ensino e, se possível, variadas (ex: múltipla escolha, verdadeiro ou falso, resposta curta, problema). Formate a saída de forma organizada, numerando cada questão.`;

            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.6, maxOutputTokens: 1500 } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao gerar atividades (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const activities = result.candidates[0].content.parts[0].text;
                    generatedActivityText.textContent = activities;
                    activityDisplayContainer.style.display = 'block';
                    btnExportActivityPdf.style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter as atividades da resposta da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
        
        async function pesquisarComIA() {
            const query = searchInput.value.trim();
            if (!query) {
                displayErrorMessage("Por favor, introduza um termo para pesquisar.");
                return;
            }
             if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A pesquisar...";
            loadingIndicator.style.display = 'block';
            searchResultsContainer.style.display = 'none';
            btnClearSearch.style.display = 'none';

            const prompt = `Responda à seguinte pesquisa de forma informativa e concisa: "${query}"`;
            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: prompt }] }],
                    generationConfig: { temperature: 0.5, maxOutputTokens: 1000 }
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao pesquisar (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const searchResult = result.candidates[0].content.parts[0].text;
                    searchResultsText.textContent = searchResult;
                    searchResultsContainer.style.display = 'block';
                    btnClearSearch.style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter resultados da pesquisa da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        async function translateTextWithAI() {
            const textToTranslate = sourceTextToTranslate.value.trim();
            const sourceLang = sourceLanguageSelect.value;
            const targetLang = targetLanguageSelect.value;

            if (!textToTranslate) {
                displayErrorMessage("Por favor, introduza o texto que deseja traduzir.");
                return;
            }
            if (!geminiFlashApiKey) {
                displayErrorMessage("A API key para o serviço Gemini não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.textContent = "A traduzir texto...";
            loadingIndicator.style.display = 'block';
            translatedTextContainer.style.display = 'none';
            btnPlayTranslatedText.style.display = 'none';

            let translationPrompt = "";
            if (sourceLang === "auto") {
                translationPrompt = `Identifique a língua do seguinte texto e traduza-o para ${targetLanguageSelect.options[targetLanguageSelect.selectedIndex].text}:\n\n"${textToTranslate}"`;
            } else {
                translationPrompt = `Traduza o seguinte texto de ${sourceLanguageSelect.options[sourceLanguageSelect.selectedIndex].text} para ${targetLanguageSelect.options[targetLanguageSelect.selectedIndex].text}:\n\n"${textToTranslate}"`;
            }
            
            try {
                const payload = {
                    contents: [{ role: "user", parts: [{ text: translationPrompt }] }],
                    generationConfig: { temperature: 0.3, maxOutputTokens: textToTranslate.length + 200 } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiFlashApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`Erro da API ao traduzir (${response.status}): ${errorData?.error?.message || response.statusText}`);
                }
                const result = await response.json();
                if (result.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const translatedText = result.candidates[0].content.parts[0].text;
                    translatedTextOutput.textContent = translatedText;
                    translatedTextContainer.style.display = 'block';
                    btnPlayTranslatedText.style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter a tradução da resposta da API.");
                }
            } catch (error) {
                displayErrorMessage(error.message);
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }


        function exportTextToPdf(text, filename = "documento.pdf") {
            if (!text || text.trim() === "") {
                displayErrorMessage("Não há conteúdo para exportar para PDF.");
                return;
            }
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                
                const margin = 15;
                const pageWidth = doc.internal.pageSize.getWidth();
                const pageHeight = doc.internal.pageSize.getHeight();
                const usableWidth = pageWidth - 2 * margin;
                let y = margin;
                doc.setFontSize(12);
                doc.setTextColor(0,0,0); 

                const lines = doc.splitTextToSize(text, usableWidth);

                lines.forEach(line => {
                    if (y + 10 > pageHeight - margin) { 
                        doc.addPage();
                        y = margin;
                    }
                    doc.text(line, margin, y);
                    y += 7; 
                });
                
                doc.save(filename);
            } catch (error) {
                console.error("Erro ao exportar para PDF:", error);
                displayErrorMessage("Ocorreu um erro ao tentar exportar o documento para PDF.");
            }
        }


        async function gerarImagemComIA() {
            const prompt = imagePromptTextarea.value.trim();
            if (!prompt) {
                displayErrorMessage("Por favor, descreva a imagem que deseja gerar.");
                return;
            }
            if (!imagenApiKey) {
                displayErrorMessage("A API key para o serviço de geração de imagem (Imagen) não está configurada.");
                return;
            }
            clearErrorMessage();
            loadingIndicator.style.display = 'block';
            loadingIndicator.textContent = "A gerar imagem com IA, aguarde...";
            aiGeneratedImageElement.style.display = 'none';
            aiImagePlaceholder.style.display = 'block';
            aiImagePlaceholder.textContent = "A sua imagem gerada por IA aparecerá aqui."; 
            aiImagePlaceholder.style.color = "#6c757d"; 
            btnDownloadAiImage.style.display = 'none';
            btnDeleteAiImage.style.display = 'none';

            try {
                const payload = { 
                    instances: [{ prompt: prompt }],
                    parameters: { "sampleCount": 1 } 
                };
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${imagenApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Erro da API Imagen:", errorData);
                    let detailedErrorMessage = `Erro da API Imagen (${response.status}): ${response.statusText}.`;
                    if (errorData?.error?.message) {
                        detailedErrorMessage += ` Detalhes: ${errorData.error.message}`;
                        if (errorData.error.message.toLowerCase().includes("billed users") || errorData.error.message.toLowerCase().includes("billing")) {
                             detailedErrorMessage = "Erro: A API de geração de imagens (Imagen) requer uma conta Google Cloud com faturação ativa. Por favor, verifique as configurações da sua conta.";
                        } else if (errorData.error.message.toLowerCase().includes("api key not valid")) {
                            detailedErrorMessage = "Erro: A API key fornecida para a geração de imagens não é válida. Por favor, verifique a API key.";
                        }
                    }
                    throw new Error(detailedErrorMessage);
                }
                const result = await response.json();
                if (result.predictions?.[0]?.bytesBase64Encoded) {
                    const base64ImageData = result.predictions[0].bytesBase64Encoded;
                    aiGeneratedImageElement.src = `data:image/png;base64,${base64ImageData}`;
                    aiGeneratedImageElement.style.display = 'block';
                    aiImagePlaceholder.style.display = 'none';
                    btnDownloadAiImage.style.display = 'inline-flex';
                    btnDeleteAiImage.style.display = 'inline-flex';
                } else {
                    throw new Error("Não foi possível obter a imagem da resposta da API. A resposta pode não conter os dados esperados.");
                }
            } catch (error) {
                displayErrorMessage(error.message); 
                aiImagePlaceholder.textContent = "Falha ao gerar imagem. Verifique a mensagem de erro acima.";
                aiImagePlaceholder.style.color = "red";
                aiImagePlaceholder.style.display = 'block';
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function baixarImagemGeradaIA() {
            if (!aiGeneratedImageElement.src || aiGeneratedImageElement.src.startsWith('#') || aiGeneratedImageElement.style.display === 'none') { 
                displayErrorMessage("Nenhuma imagem gerada por IA para baixar.");
                return;
            }
            clearErrorMessage();
            try {
                const link = document.createElement('a');
                link.download = 'imagem_gerada_ia.png';
                link.href = aiGeneratedImageElement.src;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (e) {
                displayErrorMessage("Ocorreu um erro ao tentar baixar a imagem da IA.");
            }
        }

        function apagarImagemGeradaIA() {
            aiGeneratedImageElement.src = '#'; 
            aiGeneratedImageElement.style.display = 'none';
            aiImagePlaceholder.textContent = "A sua imagem gerada por IA aparecerá aqui.";
            aiImagePlaceholder.style.color = "#6c757d";
            aiImagePlaceholder.style.display = 'block';
            btnDownloadAiImage.style.display = 'none';
            btnDeleteAiImage.style.display = 'none';
            clearErrorMessage();
        }

        function parseAudioMimeType(mimeTypeString) {
            const params = { rate: 24000, bitsPerSample: 16, channels: 1 }; 
            if (!mimeTypeString) return params;
            const parts = mimeTypeString.toLowerCase().split(';');
            parts.forEach(part => {
                const [key, value] = part.trim().split('=');
                if (key === 'rate' && !isNaN(parseInt(value))) {
                    params.rate = parseInt(value);
                } else if (key.startsWith('audio/l') && !isNaN(parseInt(key.substring(7)))) { 
                     params.bitsPerSample = parseInt(key.substring(7));
                } else if (key === 'channels' && !isNaN(parseInt(value))) {
                    params.channels = parseInt(value);
                }
            });
            if (parts[0].startsWith("audio/l")) {
                const bpsStr = parts[0].substring(7);
                if (!isNaN(parseInt(bpsStr))) {
                    params.bitsPerSample = parseInt(bpsStr);
                }
            }
            return params;
        }

        function convertPcmToWav(base64PcmData, originalMimeType) {
            console.log("A converter PCM para WAV. MimeType Original:", originalMimeType);
            const pcmData = Uint8Array.from(atob(base64PcmData), c => c.charCodeAt(0));
            const params = parseAudioMimeType(originalMimeType);
            const sampleRate = params.rate;
            const numChannels = params.channels; 
            const bitsPerSample = params.bitsPerSample;
            const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
            const blockAlign = numChannels * (bitsPerSample / 8);
            const dataSize = pcmData.length;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataSize, true); 
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); 
            view.setUint16(20, 1, true);  
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, byteRate, true);
            view.setUint16(32, blockAlign, true);
            view.setUint16(34, bitsPerSample, true);
            writeString(view, 36, 'data');
            view.setUint32(40, dataSize, true);
            new Uint8Array(buffer, 44).set(pcmData);
            let binary = '';
            const bytes = new Uint8Array(buffer);
            const len = bytes.byteLength;
            for (let i = 0; i < len; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return window.btoa(binary);
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        async function gerarFalaComIA(textToSpeak, sourceTitle = "Texto", isMultiSpeaker = false, voice1 = "Charon", voice2 = "Kore") { 
            if (!textToSpeak || textToSpeak.trim() === "") {
                displayErrorMessage("Não há texto para converter em fala.");
                audioPlayerContainer.style.display = 'none';
                return;
            }
            if (!ttsApiKey) {
                displayErrorMessage("A API key para o serviço de Text-to-Speech (TTS) não está configurada.");
                audioPlayerContainer.style.display = 'none';
                return;
            }
            clearErrorMessage();
            loadingIndicator.style.display = 'block';
            loadingIndicator.textContent = `A gerar fala para "${sourceTitle}", aguarde...`;
            audioPlayerContainer.style.display = 'none'; 

            try {
                const ttsModel = "gemini-2.5-pro-preview-tts"; 
                let speechConfigPayload = {};

                if (isMultiSpeaker) {
                    const speaker1Voice = document.getElementById('podcastSpeaker1Voice')?.value || voice1;
                    const speaker2Voice = document.getElementById('podcastSpeaker2Voice')?.value || voice2;
                    speechConfigPayload = { 
                        multiSpeakerVoiceConfig: {
                            speakerVoiceConfigs: [ 
                                { speaker: "Speaker 1", voiceConfig: { prebuiltVoiceConfig: { voice_name: speaker1Voice } } }, 
                                { speaker: "Speaker 2", voiceConfig: { prebuiltVoiceConfig: { voice_name: speaker2Voice } } }   
                            ]
                        }
                    };
                } else {
                     speechConfigPayload = { 
                        voiceConfig: { 
                            prebuiltVoiceConfig: { voice_name: voice1 } 
                        }
                    };
                }

                const payload = {
                    contents: [{ 
                        role: "user", 
                        parts: [{ text: textToSpeak }] 
                    }],
                    generationConfig: {
                        response_modalities: ["audio"],
                        temperature: 0.7, 
                        speechConfig: speechConfigPayload
                    }
                };
                
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${ttsModel}:generateContent?key=${ttsApiKey}`;
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error("Erro da API TTS:", errorData);
                    let detailedErrorMessage = `Erro da API TTS (${response.status}): ${response.statusText || 'Erro desconhecido'}.`;
                    if (errorData?.error?.message) {
                        detailedErrorMessage += ` Detalhes: ${errorData.error.message}`;
                         if (response.status === 429 || errorData.error.message.toLowerCase().includes("quota") || errorData.error.message.toLowerCase().includes("resource_exhausted")) {
                            detailedErrorMessage = "Erro: Excedeu a sua quota atual para o serviço TTS. Por favor, verifique o seu plano e detalhes de faturação ou tente novamente mais tarde.";
                             if (errorData.details) { 
                                const helpLinkObj = errorData.details.find(d => d["@type"] === "type.googleapis.com/google.rpc.Help");
                                const helpLink = helpLinkObj?.links?.[0]?.url;
                                if (helpLink) {
                                    detailedErrorMessage += ` Consulte: ${helpLink}`;
                                }
                            }
                        } else if (response.status === 500 || errorData.error.message.toLowerCase().includes("internal error")) {
                            detailedErrorMessage = `Erro Interno do Servidor (500) ao contactar a API TTS. Por favor, tente novamente mais tarde. Se o problema persistir, reporte em https://developers.generativeai.google/guide/troubleshooting. (Detalhe API: ${errorData.error.message})`;
                        } else if (errorData.error.message.toLowerCase().includes("api key not valid")) {
                            detailedErrorMessage = "Erro: A API key fornecida para o serviço de TTS não é válida ou o modelo não está acessível com esta chave.";
                        } else if (errorData.error.message.toLowerCase().includes("billed users") || errorData.error.message.toLowerCase().includes("billing")) {
                             detailedErrorMessage = "Erro: A API de TTS pode requerer uma conta Google Cloud com faturação ativa.";
                        } else if (errorData.error.message.toLowerCase().includes("model not found") || errorData.error.message.toLowerCase().includes("is not supported") || errorData.error.message.toLowerCase().includes("voice name") ) {
                            detailedErrorMessage = `Erro: O modelo TTS ('${ttsModel}') ou a voz configurada não foram encontrados ou não são suportados. Verifique o nome do modelo, a voz e a documentação da API. (Detalhe API: ${errorData.error.message})`;
                        }
                    }
                    throw new Error(detailedErrorMessage);
                }

                const result = await response.json();
                if (result.candidates && result.candidates.length > 0) {
                    const candidate = result.candidates[0];
                    if (candidate.finishReason !== "STOP") {
                         if (!candidate.content?.parts?.[0]?.inlineData?.data) {
                            let finishReasonMessage = `O modelo TTS não concluiu a geração com sucesso. Motivo: ${candidate.finishReason || 'Desconhecido'}. Não foi possível obter dados de áudio.`;
                            if (candidate.finishReason === "OTHER") { 
                                finishReasonMessage += " Isto pode indicar um problema com o texto de entrada (demasiado longo, caracteres inválidos), uma instabilidade temporária da API, ou o modelo pode não ter conseguido gerar áudio para este pedido específico. Tente com um texto mais simples ou mais curto, ou aguarde um pouco e tente novamente.";
                            }
                            throw new Error(finishReasonMessage);
                         }
                         console.warn(`O modelo TTS terminou com o motivo: ${candidate.finishReason || 'Desconhecido'}. A tentar usar os dados de áudio se disponíveis.`);
                    }

                    if (candidate.content?.parts?.[0]?.inlineData?.data) {
                        let audioDataB64 = candidate.content.parts[0].inlineData.data;
                        let finalMimeType = candidate.content.parts[0].inlineData.mimeType || 'audio/L16;rate=24000'; 
                        lastAttemptedMimeType = finalMimeType; 
                        console.log("Áudio recebido da API. MIME Type Original:", finalMimeType, "Tamanho (base64):", audioDataB64.length);
                        if (!audioDataB64.trim()) { 
                            throw new Error("Os dados de áudio recebidos da API estão vazios.");
                        }
                        if (finalMimeType.toLowerCase().includes("audio/l16") || 
                            finalMimeType.toLowerCase().includes("audio/l24") || 
                            finalMimeType.toLowerCase().includes("audio/l32") ||
                            finalMimeType.toLowerCase().includes("pcm")) {
                            try {
                                audioDataB64 = convertPcmToWav(audioDataB64, finalMimeType);
                                finalMimeType = 'audio/wav'; 
                                lastAttemptedMimeType = finalMimeType;
                                console.log("Áudio convertido para WAV. Novo MIME Type:", finalMimeType);
                            } catch (conversionError) {
                                console.error("Erro ao converter PCM para WAV:", conversionError);
                                throw new Error(`Falha ao converter áudio PCM para WAV: ${conversionError.message}`);
                            }
                        }
                        audioPlayer.src = `data:${finalMimeType};base64,${audioDataB64}`;
                        audioPlayer.onloadeddata = function() { 
                            console.log("Dados do áudio carregados (onloadeddata).");
                            audioPlayerContainer.style.display = 'block';
                            audioPlayer.play().catch(playError => { 
                                console.error("Erro ao tentar reproduzir o áudio:", playError);
                                displayErrorMessage("Erro ao iniciar a reprodução do áudio. Interação do utilizador pode ser necessária ou o formato de áudio pode não ser suportado.");
                            });
                        };
                        audioPlayer.load(); 
                        console.log("Fala gerada e src do áudio definido. A aguardar carregamento do áudio...");
                    } else {
                        console.error("Resposta da API TTS não contém dados de áudio válidos, mesmo com finishReason STOP (ou outro):", result);
                        throw new Error("Não foi possível obter os dados de áudio da resposta da API TTS. A estrutura da resposta pode estar incompleta.");
                    }
                } else {
                    console.error("Resposta inesperada da API TTS (sem candidatos):", result);
                    throw new Error("Resposta da API TTS não contém 'candidates'.");
                }
            } catch (error) {
                console.error("Erro ao gerar fala com IA:", error);
                displayErrorMessage(error.message);
                audioPlayerContainer.style.display = 'none';
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }
    </script>

</body>
</html>

